Bakalářka:
	- rozcestník do úvodu

Soon to-to:
	- user enums (with member functions)
	- realloc
	- arrays?

	- Type( args ) ctor

Future to-do:
	- Parameters indifferent 

Diplomka to-do:
	- @ctime local variable destructors - memory rollback is necessary to implement (because of breaks and returns - we have to mirror destructor call changes and then roll it back)
	- Copy-on-write, session only
	- @ctime while
	- if in function definitions
	- Decorated && expression buildStatementCode -> cleaner + cover ifs, whiles, all statements
		-> @ctime has to have a statementModifier context -- resolved on a statement AST level. If not @ctime -> statement is executed in a subsession

	Bool ctimeFunc( @ctime Int x ) { ... }
	void main() {
		@ctime Int! x;
		println( x++ > 0 && ctimeFunc( x ) );

		// Problem - ctimeFunc is executed during semantic tree building, so x++ is executed after
		// Resolution: cannot mutate @ctime variables in nonctime code + @ctime code has to be executed immidately when building semantic tree

	}

Examples - ideas:
	Fibonacci
	Factorial
	Binary tree
	Erastothenes sieve
	Inferration examples -> make user enum
	Flags example

Names:
	Lion
	Boar
	Bear
	Bull
	Crocodile
	Panther
	Ocelot
	Scorpion
	Tiger
	Wolf

Fantasy:
	Dragon
	Troll
	Centaur
	Ghoul
	Basilisk
	Griffin
	Harpy
	Hydra
	Salamander
	Siren
	Vampire
	Werewolf
	Minotaur

Special:
	Bestiary

For presentation:
	Number slides (x/total)

BBasile (does simple editor with syntax highlight): b2.temp@gmx.com

-- Problem with @ctime variable destructor calls when calling break; or return; or so - they can't be actually called
	- @ctime destructors would be called "last" ? Or not at all?


-- Reflection of comments + documentation generation
-- Ability to pass ctime string using a command line in beast

FIX!!
Void test( 5 + 4 ) {

}

Void main() {
	@ctime test( 5 + 4 ); // error: 5 + 4 not ctime
}

-- What to do with
Void foo( Int!? a, @ctime Int!? b ) {
	a++;
	b++;
}

Void main() {
	@ctime Int! x;

	foo( x, x );
}

-- What to do with
class C( Int!? x ) {
	Void test() {
		x++; // Obviously x data must be constantiatized -- this is handled by rule "changing ctime value from rtime scope"
		stdout.write( x );
	}
}

Void main() {
	@ctime Int! a = 0;
	C( a ) c;

	c.test();
	a++;

	c.test(); // What now? This is kinda screwed... a should be constantiatized or sumthing
}

---
class C {
 
public:
    @wipOrConst Int! x;
 
}
 
C! getC() {
    @wip C! result = new @wip C();
    result.x = 5;
    return result;
}
 
void main() {
    C! c = getC();
 
    c.x = 5; // Error
}