% !TeX spellcheck = cs_CZ
% !TeX root = projekt.tex

\newcommand{\ctimeNoXSpace}{\inlineCode{@ctime}}
\newcommand{\ctime}{\ctimeNoXSpace\xspace}
\newcommand{\nonctime}{ne-\inlineCode{@ctime}\xspace}

\renewcommand\chapterautorefname{kapitola}
\renewcommand\sectionautorefname{podkapitola}
\renewcommand\subsectionautorefname{oddíl}
\renewcommand\subsubsectionautorefname{pododdíl}

\chapter{Úvod}
Tento dokument popisuje a zdůvodňuje ta nejdůležitější rozhodnutí, která byla vykonána při procesu návrhu imperativního kompilovaného programovacího jazyka Beast a vzorového překladače pro něj. Rámcově prozkoumává syntaktické i sémantické prvky moderních programovacích jazyků a zavádí i koncepty nové.

Tato práce se zaměřuje zejména na nový koncept "líhnutí kódu", který má poskytovat rozsáhlé možnosti metaprogramování v kompilovaných jazycích. Navržený programovací jazyk se hodně inspiruje jazyky C++ a D\footnote{\url{http://dlang.org/}}. Tyto jazyky budou používány pro srovnávání syntaxe a efektivity psaní kódu.

Příklady kódů z jazyka Beast uvedené v tomto dokumentu čerpají z kompletního návrhu jazyka, případně pracují se standardní knihovnou (která ještě ani nebyla navržena); kompilátor vytvořený v~rámci bakalářské práce ale implementuje pouze malou část zdokumentované či zamýšlené funkčnosti -- většinu uvedených kódů tedy kompilátor není schopný zpracovat.

Motivací a současně i cílem této práce je snaha vnést nový pohled do oblasti kompilovaných jazyků, jak celkovou kompozicí jazyka, tak novými nápady, a přiblížit jej akademické komunitě skrze demonstrační kompilátor.

\paragraph{Struktura práce}
\begin{itemize}
	\item Kapitola \ref{chap:languageProps} se zabývá spekulacemi nad zavedením různých vlastností a~prvků do jazyka.
	\item Kaptiola \ref{ctime} se potom věnuje novému konceptu líhnutí kódu, který jazyk Beast zavádí.
	\item Kapitola \ref{chap:compiler} se věnuje implementaci demonstračního kompilátoru.
\end{itemize}

\begin{comment}
Mou hlavní motivací je nespokojenost se stávajícími programovacími jazyky. Programování mám jako koníčka už od nějakých dvanácti let, a tak jsem ještě před nastoupením na FIT získal nějaké zkušenosti z psaní aplikací v Object Pascalu (Delphi), C++ (Qt, SDL + OpenGL) a PHP (webové aplikace). FIT pak můj repertoár (i když jen rámcově) rozšířil na valnou většinu dnes používaných jazyků. Bohužel jsem ale nenarazil na žádný, který by splňoval mé požadavky. Rozhodl jsem se tedy využít nutnost napsání bakalářské práce k~uskutečnění mého dlouholetého snu.

\paragraph{Jazyk D}
Mému srdci nejbližší jazyk, na který jsem ve svém pátrání narazil, byl jazyk D. Jedná se o kompilovaný jazyk vycházející z C++ (binárky jsou do jisté míry kompatibilní) s~velice podobnou syntaxí. Největší rozdíly jsou modulový systém\footnote{\url{http://dlang.org/spec/module.html}} (zdrojový kód je rozdělen do modulů, které se vzájemně, i rekurzivně, importují; odpadá nutnost psát hlavičkové soubory), značně rozšířená funkčnost metaprogramování s šablonami a~rozšířená schopnost vykonávat funkce za doby kompilace.

D mi byl velikou inspirací při navrhování mého jazyka. Bohužel i v D jsem narazil na strop možnosti (ačkoli byl značně výš než třeba v C++), kdy některé věci nešly napsat tak jednoduše, jak bych chtěl. Tento jazyk však dokazuje, že tato bariéra může být mnohem dál. Já ji chci ve svém jazyku ještě více posunout. 
\end{comment}

\chapter{Vlastnosti a syntaxe jazyka} \label{chap:languageProps}
Naším cílem je navrhnout jazyk pro obecné použití, který by se dal použít na maximálním počtu platforem, například i ve vestavěných systémech. Složitější struktury se tím pádem budeme snažit řešit spíše vhodnou abstrakcí než zaváděním prvků, které kladou zvýšené nároky na výkon a paměť.

Budeme navrhovat kompilovaný jazyk. Ačkoli interpretované jazyky mají jisté výhody, platí se za ně pomalejším kódem a nutností zavádět interpret do počítačů, kde má jazyk běžet. Pro zjednodušení práce při psaní překladače nebudeme ale překládat přímo do strojového kódu, ale do jazyka C/C++.

Abychom usnadnili přechod programátorů k našemu jazyku a~zlepšili parametry křivky učení, je vhodné se inspirovat již existujícími jazyky. Vzhledem k tomu, že se jedná o~kompilovaný jazyk, je nejrozumnější vycházet ze syntaxe rodiny jazyků C, které jsou hojně rozšířené a zažité. Tento jazyk se inspiruje konkrétně jazyky C++ a D. Z~těchto jazyků bude přejímat i paradigmata a základní koncepty. Náš jazyk bude tedy umožňovat strukturované, funkcionální i objektově orientované programování.

\section{Existující prvky programovacích jazyků}
V oblasti návrhu programovacích jazyků již bylo vytvořeno mnoho konceptů a kategorizováno mnoho vlastností, které jazyk definují. V tomto oddílu si přiblížíme ty nejznámější z~nich a budeme diskutovat o jejich začlenění do našeho programovacího jazyka.

Informace v tomto oddílu jsou čerpány z referencí programovacích jazyků C++\cite{CppRef}, D\cite{DSpec}, Rust\cite{RustRef} a tutoriálových stránek pro jazyky Java\cite{JavaTut} a Scala\cite{ScalaTut}.

\subsection{Modularita}
Pro větší projekty, které jazyk Beast také cílí podporovat, je rozdělení kódu do menších částí -- modulů -- nezbytné. Přístup, kde u modulů byla oddělená deklarační (hlavičková) a~definiční část (například u jazyků Object Pascal a C/C++), byl již překonán a~kompilátory moderních jazyků již rozhraní mezi moduly odvozují z definic uvnitř jednotlivých modulů. Tento přístup je praktičtější, protože vytváření a udržování hlavičkových sekcí bylo časově náročné (programátor jinak musel vše psát a upravovat dvakrát). Jazyk Beast zavede systém modulů podobný jazykům D a Java, které jsou vytvořeny v tomto duchu.

\subsection{Systém dědičnosti tříd} U kompilovaných jazyků se nejběžněji využívá třídní systém využívající dědičnost a tabulky virtuálních metod. Tohoto konceptu využívají i jazyky C++ a D, nicméně v detailech se poněkud liší. Zatímco v C++ existuje jen jeden typ objektu, který pracuje s dědičností (\textit{class} a \textit{struct} jsou z pohledu dědění identické), a~to s~dědičností vícenásobnou a případně i~virtuální, D~používá obdobný systém jako Java -- třídy (\textit{class}) mohou mít maximálně jednu rodičovskou třídu (myslí se jeden přímý předek, rodičovská třída může dědit od další třídy), navíc ale existují rozhraní (\textit{interfaces}). Ta však mohou obsahovat pouze funkce (tedy žádné proměnné), což omezuje jejich možnosti.

Jazyk D poskytuje k vícenásobné dědičnosti částečnou alternativu ve formě tzv. \textit{template mixins}\footnote{\url{https://dlang.org/spec/template-mixin.html}} -- které fungují podobně jako kopírování bloků kódu přímo do těla třídy. Ty se kombinují s rozhraními -- funkce deklarované v rozhraních obsahují implementace v \textit{mixins}, které se vkládají do těl tříd. Proměnné jsou napodobeny \textit{gettery} a jako s proměnnými.

\begin{dcode}[Příklad použití \textit{mixin template} v jazyce D]
// D
mixin template ITestImpl() {

private:
	int x_;
	
public:
	void x( int set ) {
		x_ = set;	
	}
	int x() {
		return x_;	
	}
	void foo() {
		// Do something	
	}

}

interface ITest {
	void x( int set );
	int x();
	void foo();
}

class Parent {
}

class Child : Parent, ITest {
	mixin ITestImpl;
}

void main() {
	Child child = new Child;
	child.x = 5; // Ok (equals to x(5) )
	child.x += 5; // Error, this is not possible
	
	ITest itest = cast( ITest ) child;
	itest.foo();
}
\end{dcode}

Použití \textit{mixin templates} není ale plnohodnotnou náhražkou vícenásobné dědičnosti:
\begin{itemize}
	\item Rozbíjí model dědičnosti (na \textit{mixins} se nelze odkazovat, proto se kombinují s rozhraními).
	\item Protože jsou vložené funkce prakticky součástí třídy, nefunguje v~určitých případech kontrola přepisování (\textit{overridingu}).
	\item Programátor musí udržovat zvlášť deklarace v rozhraních a~definice v \textit{mixin templates}.
\end{itemize}

Ačkoli je implementace systému vícenásobné dědičnosti tak, jak je v C++, složitější, její implementace je uskutečnitelná, kód nezpomaluje (v porovnání s kódem s ekvivalentní funkčností napsaným alternativním způsobem) a fakticky rozšiřuje možnosti jazyka. C++ model dědičnosti umí vše, co umí Javovský model, a ještě víc. Proto bude jazyk Beast umožňovat vícenásobnou třídní dědičnost; nicméně implementace systému třídní dědičnosti není primárním cílem projektu, a tak bude systém v rámci demonstračního kompilátoru značně omezen.
%TODO přidat podpůrnou referenci - nelze najít

\subsection{Automatická správa paměti -- garbage collector}
Zavedení \textit{garbage collectoru} (dále jen GC) nenabízí pouze výhody \cite{GarbageCollectionHarmful} -- programy mohou být pomalejší, GC zvyšuje nároky na CPU a paměť (těžko se zavádí v mikroprocesorech); navíc efektivní implementace GC je velice složitá.

Rozumným východiskem se jeví být volitelné používání automatické správy paměti. Beast by měl umožňovat efektivní napsání GC přímo v jazyce; GC by tedy mohla být jedna ze základních knihoven. Vzhledem k už tak velkému rozsahu plánované práce je však GC jen plánem do budoucna.

\subsection{Implicitní konstantnost proměnných} \label{implicitConst}
Koncept konstantnosti proměnných byl zaveden jako prvek statické kontroly při psaní kódu. Označení proměnné za konstantní ale u jazyku C++ (i D, Java, ...) vyžaduje napsání dalšího slova (modifikátoru \textit{const} u C, C++ a D, \textit{final} u Javy), a tak tuto praktiku (označovat všechno, co se dá, jako konstantní) spousta programátorů neaplikuje, zčásti kvůli lenosti, zčásti kvůli zapomnětlivosti. Konstantnost je, když už je zavedena, třeba dodržovat v celém projektu (díky jejím tranzitivním vlastnostem) a její pozdní zavedení bývá pracné a~zpravidla nelze udělat postupně kvůli tzv. \textit{const poisoning} efektu -- zavedení konstantní korektnosti \cite{ConstCorrectness}\cite{ConstCorrectness2} v části kódu vyžaduje konstantní korektnost všech typů, které daný kód používá (a~ty typy vyžadují konstantní korektnost všech funkcí, které využívají, a tak dále).

Některé jazyky (například Rust\footnote{\url{https://doc.rust-lang.org/nightly/book/mutability.html}}) přišly s opačným přístupem: všechny proměnné jsou implicitně konstantní a programátor musí pro deklaraci nekonstantních proměnných použít speciální syntaktickou konstrukci. Tento přístup má vést programátory ke korektnímu používání konstantních a mutabilních proměnných. Jazyk Beast tento přístup také aplikuje.

Je tedy třeba určit syntaktickou konstrukci pro označování nekonstantních proměnných. V rámci koherence syntaxe jazyka (která je rozvedena v dalších kapitolách tohoto textu), připadají  v úvahu dvě možnosti:
\begin{enumerate}
	\item Vytvoření dekorátoru\footnote{\BeastRef{Decorators}}, nejlogičtěji \inlineCode{@mutable} nebo \inlineCode{@mut}
	\item Vyčlenění operátoru; nejlepším kandidátem je suffixový operátor \inlineCode{Type!}, protože nemá žádnou standardní sémantiku, je nepoužitý a znak vykřičníku je intuitivně asociován s výstrahou, což je asociovatelné s mutabilitou.
\end{enumerate}

Při návrhu jazyka Beast byla zvolena druhá možnost, především kvůli "upovídanosti" kódu a~ještě z dalšího důvodu, který je popsán v následujícím oddílu.

\subsection{Tranzitivita konstantnosti přes reference} \label{constPropagation} Jazyk D je navržen tak, že je-li ukazatel konstantní (nelze měnit adresu, na kterou ukazuje), je přístup k paměti, na kterou ukazuje, také konstantní. Není tedy možné mít konstantní ukazatel na nekonstantní paměť. Tento mechanismus se nejvíce projevuje při konstantním referencování dat:
\begin{dcode}
// D
class C {
	int *x;
}

void main() {
	C c = new C;
	c.x = new int( 5 );
	
	const C c2 = c;
	*c2.x = 6; // Error: cannot modify const expression *c2.x
}
\end{dcode}

Polemika nad tímto tématem je mimo rámec tohoto projektu; zdá se, že zatím ani nebyla veřejně vedena, nicméně střípky informací můžete nalézt na \cite{FullyTransitiveConst} a \cite{TransitiveConst2}. Vynucená tranzitivní konstantnost se zdá být zbytečně limitující a~bez zřejmých přínosů. V jazyce Beast nebude; můžeme mít konstantní ukazatel na nekonstantní data.

Chceme-li mít nekonstantní ukazatel na nekonstantní data, musíme tedy specifikovat mutabilitu dvakrát. Syntaktický zápis pro takovou referenci by vypadal takto (syntaxe pro referenci je \inlineCode{Typ?}, viz \autoref{pointers}; příklady reflektují alternativy syntaktického zápisu referencí, které jsou uvedené v oddílu \ref{implicitConst}):
\begin{enumerate}
	\item \inlineCode{@mut ( @mut Typ )?}
	\item \inlineCode{Typ!?!}
\end{enumerate}

Další možností by bylo se inspirovat gramatikou C++ (po vzoru \inlineCppCode{const int * const} by měl zápis formu \inlineCode{@mutable Int ? @mutable}), nicméně ta je všeobecně považována za velice matoucí -- dochází tam ke kombinování suffixových a prefixových modifikátorů podle neintuitivních pravidel. Čistě suffixový zápis má jasná pravidla a jednoduchá a~značně snižuje potřebu využívat závorky.

Jak bylo uvedeno v oddílu \ref{implicitConst}, pro jazyk Beast byla zvolena druhá varianta.

\paragraph{Srovnání syntaxe C++, D a Beast}
\begin{cppcode}
	// C++
	int a, b; // Mutable integer
	const int c, d; // Const integer
	int *e, *f; // Mutable pointer to mutable integer
	const int *g, *h; // Mutable pointer to const integer
	int * const i, * const j; // Const pointer to mutable integer
	const int * const k, * const l; // Const pointer to const integer
\end{cppcode}
\begin{dcode}
	// D
	int a, b; // Mutable integer
	const int c, d; // Const integer
	int* e, f; // Mutable pointer to mutable integer
	const( int )* g, h; // Mutable pointer to const integer
	// const pointer to mutable integer not possible
	const int* k, l; // Const pointer to const integer
\end{dcode}
\begin{code}
	// Beast
	Int! a, b; // Mutable integer
	Int c, d; // Const integer
	Int!?! e, f; // Mutable reference to mutable integer
	Int?! g, h; // Mutable reference to const integer
	Int!? i, j; // Const reference to mutable integer
	Int? k, l; // Const reference to const integer
\end{code}

\subsection{Typová kontrola, konverze typů a odvozování typů}
Beast má podobný mechanismus typových kontrol jako jazyky C++ a D:
\begin{itemize}
	\item Typy mohou být implicitně konvertibilní do jiných typů. Proces konverze je definován v jednom z typů (přetížením funkcí \inlineCode{#implicitCast})\footnote{\BeastRef{Type casting}}. Implicitní konverze se provádí sama v případě potřeby\footnote{Implicitní konverze ovlivňuje rezoluci volání přetížených funkcí, \beastRef{Overload resolution}}.
	\item Typy mohou být explicitně konvertibilní do jiných typů (funkce \inlineCode{#explicitCast}). K~explicitnímu přetypování se používá výhradně funkce\\\inlineCode{var.to(Type)} (lze použít i k implicitnímu přetypování).
\end{itemize}

Důvodem k jiné syntaxi oproti C++ je opět snaha o zjednodušení pravidel a zvýšení přehlednosti kódu.

\begin{cppcode}
// C++
const int x = *( ( const int* )( voidPtr ) );
\end{cppcode}

\begin{code}
// Beast
Int x = voidRef.to( Int? );
\end{code}

Problémem souvisejícím s tímto tématem je i odvozování typů pro výrazy, u kterých se může typ měnit na základě kontextu. Takovým případem jsou například lambda výrazy v~jazyce D. V něm je platný například tento kód:

\begin{dcode}
// D
int function( int ) func = x => x * 2;
\end{dcode}

Kód \inlineDCode{x => x * 2} je validní syntaktická konstrukce, která definuje funkci, která přijímá jeden parametr a navrací dvojnásobek jeho hodnoty. Tato konstrukce však samotná neobsahuje dostatečná data pro definici funkce -- ta se dedukují až na základě kontextu, v~tomto případě podle toho, že se danou lambda funkci pokoušíme uložit do ukazatele na funkci s~konkrétním prototypem.

Při sémantické analýze tedy kompilátor musí při zpracovávání výrazu brát v potaz i to, jaký typ je u výrazu očekáván. Tento fakt může způsobit, že se jeden výraz musí analyzovat vícekrát, například v tomto případě:
\begin{dcode}
// D
import std.stdio;

void foo( int function(int) func ) {
	writeln( "INT RESULT: ", func( 3 ) );
}

void foo( string function(int) func ) { $\label{typeInfer:1}$
	writeln( "STRING RESULT: ", func( 3 ) );
}

void main() {
	foo( x => x + 3 );
}
\end{dcode}

Zde se sémantická analýza výrazu \inlineDCode{x => x + 3} musí provést pro každé přetížení funkce \inlineDCode{foo} zvlášť. V případě funkce na řádku \ref{typeInfer:1} sémantická analýza selže, protože výraz \inlineDCode{x + 3}, kde \inlineDCode{x} je typu \inlineDCode{int}, je také typu \inlineDCode{int}, který není implicitně konvertibilní na typ \inlineDCode{string}.

Typové odvozování se používá i v dalších případech, například u literálů polí, \inlineDCode{auto} deklaracích apod. Jazyk Beast cílí podporovat všechny tyto případy, v rámci této práce však z časových důvodů nemusí být do demonstračního kompilátoru zavedeny.

V souvislosti s odvozováním typů zavádí jazyk Beast novou konstrukci \inlineCode{:identifier}, viz \autoref{colonIdent}.

\subsection{Reference, ukazatelé a jejich syntaxe} \label{pointers}
Typ ukazatel umožňující ukazatelovou aritmetiku je v dnešní době považován za potenciálně nebezpečný prvek, který by se měl užívat jen v nutných případech. Toto se řeší zavedením referencí, které v různých jazycích fungují mírně rozdílně, všeobecně se ale dá říci, že se jedná o ukazatele, které nepodporují ukazatelovou aritmetiku.

C++ reference neumožňují měnit adresu odkazované paměti. V praxi ji ale programátor poměrně často potřebuje měnit; musí se proto uchylovat k ukazatelům, které podporují ukazatelovou aritmetiku a pro přístup k odkazované hodnotě je třeba buď použít dereferenci (která je implementována prefixovým operátorem \inlineCppCode{*ptr} a má tendenci znepřehledňovat kód) nebo speciální syntaktickou konstrukci (místo \inlineCppCode{x.y} \inlineCppCode{x->y}) pro přístup k prvkům odkazované hodnoty.

D k problematice přistupuje takto:
\begin{itemize}
	\item Třídy jsou vždy předávané odkazem; adresa odkazované instance třídy se dá měnit, ukazatelová aritmetika není podporována (jako v Javě), přetěžování operátoru \inlineCode{a = b} není povoleno pro třídy jako levé operandy. Kromě tříd existují i struktury, které jsou předávané hodnotou; ty však nepodporují dědičnost.
	\item Existuje typ ukazatel, který pracuje s ukazatelovou aritmetikou. Pro přístup k odkazovanému prvku je třeba použít dereferenci (\inlineCode{*x}); k prvkům odkazované hodnoty lze použít klasické \inlineCode{x.y} (u C++ je třeba \inlineCode{x->y}). U dvojitého ukazatele je již potřeba použít dereferenci.
	\item Existuje i reference podobná té v C++, nicméně ta se dá použít pouze v několika málo případech (například v parametrech a návratových typech funkcí)
\end{itemize}

Vynucené předávání instancí tříd odkazem má ale několik nevýhod:
\begin{itemize}
	\item Programátor musí zajišťovat konstrukci (případně i destrukci) objektů. V~jazyce D~se automatická konstrukce zajišťuje automaticky těžko (jde to, ale jen s určitými kompromisy).
	\item Způsobuje více alokací a dealokací.
	\item Dynamická alokace tříd, které jsou prvky jiných tříd/struktur narušuje lokalitu dat, což vede ke zvýšeným \textit{cache misses} a zpomalení aplikace.
\end{itemize}

\subsubsection{Řešení v jazyce Beast} 
Beast má umožňovat nízkoúrovňové programování, typ ukazatel s ukazatelovou aritmetikou je tedy nutné zavést. Na druhou stranu je ale vhodné nabídnout alternativu pro "běžné" případy užití, které se většinou týkají vytváření instancí tříd na haldě a manipulace s~nimi. Proto jazyk standardně nabízí dva ukazatelové typy, které jsou pojmenovány ukazatel a~reference.

Způsob deklarace ukazatelů je v C++ i D problematický z hlediska syntaktické analýzy. Výraz \inlineCode{a * b} může totiž znamenat buď výraz násobení \inlineCode{a} krát \inlineCode{b}, stejně tak ale může znamenat deklaraci proměnné \inlineCode{b} typu ukazatel na \inlineCode{a}~(obdobně i u reference). Nejjednodušším řešením je použití jiného znaku pro označování ukazatelů.

V jazyce Beast je tímto znakem otazník (\inlineCode{?}). V~C++ a~D~je používán pouze v ternárním operátoru (\inlineCode{cond ? expr1 : expr2}), kteréhož funkčnost Beast obstarává jiným způsobem\footnote{Viz \autoref{ternary}}.

Ukazatel v jazyce Beast funguje skoro stejně jako v C++; podporuje ukazatelovou aritmetiku. Na dereferenci se ale nepoužívá prefixový operátor \inlineCode{*ptr} kvůli gramatickým konfliktům a protože může způsobovat nepřehlednost kódu a nejasnosti v prioritě operátorů (například u výrazu \inlineCppCode{*p++}). Místo toho se používá \inlineCode{ptr.data}; přístup k prvkům odkazované hodnoty není možný jiným způsobem. K získání ukazatele se také, kvůli stejným důvodům jako u~dereference, nepoužívá prefixový operátor \inlineCppCode{&variable}, nýbrž \inlineCode{variable.#addr}. Typ ukazatel není deklarován pomocí zvláštní syntaktické konstrukce (suffixový operátor \inlineCode{Type?} přenechává hojněji používaným referencím), jedná se o kompilátorem definovanou třídu \inlineCode{Pointer( @ctime Type referencedType )}.

Reference je podobná referencím v C++, navíc ale umožňuje změnu odkazované adresy (může mít i hodnotu \inlineCode{null}). Neumožňuje zanořování -- nelze definovat referenci na referenci (ukazatel na referenci ale možný je). Chová se stejně jako odkazovaná hodnota, až na několik výjimek:
\begin{itemize}
	\item Je přetížen operátor \inlineCode{ref := var} a \inlineCode{ref := null}, který je určen pro změnu odkazované adresy reference.
	\item Je přetížen operátor \inlineCode{ref is null}, který navrací, zda má reference hodnotu \inlineCode{null}.
	\item \inlineCode{ref.#addr} vrací ukazatel na referenci. \inlineCode{ref.#refAddr} vrací ukazatel na odkazovaný objekt.
\end{itemize}

Všechny typy jsou implicitně konvertibilní na referenci (daného typu i jeho předků). Reference jsou implicitně konvertibilní na odkazovaný typ, na reference předků odkazované třídy a explicitně konvertibilní na referenci jakéhokoli typu; při těchto explicitních konverzích probíhá dynamická typová kontrola, jejíž výsledek může být \inlineCode{null}.

Reference v jazyce Beast pokrývají naprostou většinu případů užití ukazatelů při programování na vyšších úrovních abstrakce, a to se syntaxí takovou, že programátor nemusí rozlišovat referenci od normální proměnné. K programování na nižší úrovni se dá použít konvenční typ ukazatel \inlineCode{Pointer( T )}.

\subsection{Dekorátory} \label{decorators}
Pro tento koncept mívají jazyky, které ho zavádějí, různé pojmenování. V Javě se používá pojem "anotace," v~Pythonu "dekorátory," v D "uživatelem definované atributy," v C\# a Rustu "atributy." Všechny zmíněné jazyky používají podobnou syntaktickou konstrukci, která se umísťuje před deklarace proměnných, tříd, typů, atp. Jejich potenciál se jazyk od jazyku liší; souhrnně se ale dá říci, že programátorům umožňují některé z těchto možností:
\begin{itemize}
	\item Přiřazování metadat k symbolům; tato metadata pak jazyk umožňuje v době kompilace, případně za běhu, v rámci reflexe získávat.
	\item Měnit chování symbolů; například nahrazení funkce jinou (syntaktická podpora pro návrhový vzor dekorátor \cite{Wiki_Decorator}).
	\item Direktivy kompilátoru -- například \inlineCode{@Override} v Javě.
\end{itemize}

Jazyk Beast zamýšlí poskytnout všechny výše uvedené případy užití. Syntaxi dekorátorů převezme z D/Javy (\inlineCode{@identifier}, případně \inlineCode{@identifier(args)}, které se umísťují před dekorovanou deklaraci/příkaz/konstrukci). Pro koherenci jazyka budou dekorátory využity na všechny dostupné direktivy a modifikátory pro kompilátor; například jazyky Java a~D~používají pro některé direktivy dekorátory (například \inlineCode{@Override}) a pro jiné klíčová slova (například \inlineCppCode{public}).

Z časových důvodů bude v rámci tohoto projektu implementováno užití dekorátorů pouze jako direktiv pro kompilátor. Pro více informací o dekorátorech v jazyce Beast \beastRef{Decorators}.

\subsection{Vykonávání fukncí za doby kompilace}
Vykonávání funkcí za doby kompilace je jedna z nutných prekvizit pro realizaci konceptu líhnutí kódu, viz \autoref{ctime}.

\subsection{Metaprogramování} \label{metaprogramming}
Metaprogramování je koncept, jehož realizace dává programátorovi možnost přistupovat ke kódu "jako k datům," tedy kód pomocí kódu samotného určitým způsobem číst (například získání seznamu proměnných ve třídě, zjištění návratového typu funkce, atp.) a~přidávat/upravovat (například vytvořit třídy pro binární strom nad zadaným typem nebo na základě seznamu proměnných ve třídě vygenerovat funkci, která zajistí její korektní serializaci). Do tohoto konceptu spadá například šablonování a reflexe.

Současné kompilované jazyky realizují metaprogramování jen v omezené míře. Jazyk Beast zavádí koncept líhnutí kódu (viz \autoref{ctime}), který v tomto směru nabízí mnohem více možností.

\paragraph{Deklarace s \inlineDCode{if} v jazyce D}
V rámci šablonování nabízí jazyk D velice praktickou konstrukci, kdy se mezi hlavičku a tělo deklarace (třídy, funkce, mixinu, ...) vloží \inlineDCode{if( expr )}, kde \inlineDCode{expr} je logický výraz, který se vyhodnocuje za doby kompilace. Tento výraz může mimo jiné obsahovat šablonové argumenty deklarace a pokud je vyhodnocen jako \inlineDCode{false}, daná deklarace je pro zadané šablonové argumenty považována za neplatnou a kompilátorem ignorována\footnote{Bližší dokumentace o této konstrukci v jazyce D je na stránce \url{https://dlang.org/concepts.html}.}.

Níže uvedená funkce v jazyce D
\begin{dcode}
// D
void writeToBuffer( T )( Buffer buf, const ref T data )
	if( isScalarType!T )
{
	buf.write( &data, T.sizeof )
}
\end{dcode}
je například platná jen pro skalární typy. Tomuto kódu by odpovídal následující C++ kód až na ono omezení, které typy šablona přijímá -- taková kontrola v mnoha případech v C++ není realizovatelná vůbec a v jiných jen pomocí různých "triků", které činí kód nepřehledným.

\begin{cppcode}
// C++
template< typename T >
void writeToBuffer( Buffer &buf, const T& data ) {
	buf.write( &data, sizeof( T ) );
}
\end{cppcode}

Jazyk Beast tuto konstrukci přejímá z jazyka D beze změn.

\subsection{Mixins}
Dalším existujícím konceptem v programovacích jazycích jsou tzv. \textit{mixins}. V podstatě se jedná o prostředek ke "slepému" vkládání/kopírování kódu. Jako příklad poslouží několik kódu z jazyka D, který tento koncept implementuje\footnote{Bližší dokumentace \textit{mixins} v jazyce D je na stránkách \url{https://dlang.org/mixin.html} a \url{https://dlang.org/spec/template-mixin.html}.}.

\begin{dcode}
// D
mixin template MyMixin {
	int a;	
	void setA( int val ) {
		a = val;	
		onAChanged();
	}
}

class C {
public:
	int b;
	mixin MyMixin;
	void onAChanged() {
		writeln( "C.a changed" );	
	}
}

class D {
public:
	int c;
	mixin MyMixin;	
	void onAChanged() {
		writeln( "D.a changed" );	
	}
}

void main() {
	import std.stdio;
	
	C c = new C;
	D d = new D;
	
	c.setA( 5 );
	writeln( c.a );
	
	d.setA( 9 );
	writeln( d.a );
}
\end{dcode}

Ve výše uvedeném příkladu jsme vytvořili \inlineDCode{mixin template MyMixin}, který jsme následně vložili do tříd \inlineDCode{C} a \inlineDCode{D}. Jak bylo uvedeno dříve, \textit{mixins} jsou velice podobné kopírování textu a~kompilátor se chová téměr stejně, jako kdybychom obsah \inlineDCode{MyMixin} přímo vložili do daných tříd. Tato vlastnost umožňuje do jisté míry suplovat vícenásobné dědění, které jazyk D~nepodporuje (místo toho nabízí \textit{interfaces}, podobně jako Java), nicméně program ztrácí na přehlednosti a bezpečnost kódu je nižší. Delší rozvedení problematiky je mimo rámec této práce.

Jazyk D nabízí ještě jednu formu \textit{mixins} -- jedná se o konstrukt \inlineDCode{mixin( code )}, kde \inlineDCode{code} je výraz, který je za doby kompilace vyhodnocen jako řetězec. Obsah tohoto řetězce je pak vložen na místo konstruktu jako kód.

\begin{dcode}
// D
string generateSampleCode( string operator ) {
	return "a " ~ operator ~ " 4;";
}

void main() {
	int a = 3;
	mixin( generateSampleCode( "+=" ) ); // Becomes "a += 4";
	// a == 7
}
\end{dcode}

Tato forma \textit{mixin}u společně s vykonáváním funkcí za doby kompilace (CTFE) značně zvyšuje možnosti metaprogramování. V praxi ale bývá kód, který \textit{mixins} využívá, nepřehledný.

Ačkoli jazyk Beast podporuje vícenásobnou dědičnost, koncept \textit{mixins} nabízí rozšíření možností, a proto jejich zavedení stojí za úvahu. Z časových důvodů je ale prozatím přeskočen.

\subsection{Výjimky}
Systém výjimek má napříč jazyky velice podobnou formu využívající konstrukce typu \inlineDCode{try-catch-finally} a příkazu typu \inlineDCode{throw}. Koncept je všeobecně známý, není tedy třeba ho tu rozepisovat.

Přestože je systém výjimek takřka nezbytnou součástí moderních programovacích jazyků, tato práce se zaměřuje spíše na implementaci nového konceptu líhnutí kódu (viz \autoref{ctime}) a další inovativní koncepty. Výjimky nejsou triviální na implementaci; jejich absence nenarušuje syntaktickou celistvost jazyka a pro demonstrační kompilátor nebude příliš velikým omezením funkčnosti.

\subsection{Lambda výrazy}
Lambda výrazy, také nazývané anonymní funkce, jsou jazyková konstrukce umožňující definovat funkce, které nemají identifikátor. Aby tento koncept fungoval, funkce v daném jazyce musí být tzv. \textit{first-class citizens} -- musí s nimi být možné nakládat jako s hodnotami proměnných, tedy ukládat je do proměnných, předávat je jako argumenty nebo je navracet při volání funkcí (to je dnes naprosto běžné).

Mnoho moderních programovacích jazyků lambda výrazy podporuje, mezi nimi i naše vzorové jazyky C++ a D. Realizace základních lambda výrazů je triviální (pomocí ukazatele na funkci), návrh se ale komplikuje, pokud chceme v anonymní funkci používat nestatické proměnné z rámce, ve kterém byla funkce definována. Bližší popis lambda výrazů je mimo rámec této práce. Specifikace jazyka Beast lambda výrazy zahrnuje, z časových důvodů ale v demonstračním kompilátoru zahrnuty nejsou.

\subsection{Rysy (traits)}
Koncept \textit{traits} (rysy) se napříč jazyky různí jak syntaxí, tak funkčností. V některých jazycích nemá syntaktickou podporu a je spíše používán jako návrhový vzor. Všeobecně se jedná o~způsob přidávání funkčnosti třídám a~zároveň standardizace této funkčnosti mezi třídami (třída, která implementuje daný rys, musí poskytovat jeho funkčnost) mimo konvenční systém dědičnosti. Uveďme si několik různých přístupů k tomuto konceptu:

\begin{itemize}
	\item Jazyk Rust\footnote{Více informací o \textit{traits} v jazyku Rust na adrese \url{https://doc.rust-lang.org/book/traits.html}} na konceptu \textit{traits} zakládá celé objektově orientované paradigma. V~Rustu neexistují třídy; existují pouze struktury (\textit{struct}), které mohou obsahovat pouze proměnné (tedy žádné funkce), \textit{traits}, které obsahují prototypy funkcí, a implementace \textit{traits} pro dané struktury. Definice struktur, \textit{traits} a implementací mohou být v různých souborech.
	\begin{rustcode}[Příklad \textit{traits} v jazyce Rust, převzato z~\url{https://doc.rust-lang.org/book/traits.html}]
// Rust
struct Circle {
	x: f64,
	y: f64,
	radius: f64,
}

trait HasArea {
	fn area(&self) -> f64;
}

impl HasArea for Circle {
	fn area(&self) -> f64 {
		std::f64::consts::PI * (self.radius * self.radius)
	}
}
	\end{rustcode}
	
	\item Jazyk Scala\footnote{Více informací o \textit{traits} v jazyce Scala na adrese \url{http://joelabrahamsson.com/learning-scala-part-seven-traits/}} využívá rysy k napodobení vícenásobné dědičnosti (kterou jazyk nepodporuje). \textit{Traits} zde rozšiřují koncept rozhraní (\textit{interfaces}) o možnost implicitní implementace funkcí a přidání proměnných (které jsou ale "abstraktní" -- v rysu jsou obsaženy pouze jako reference a musí být definovány ve třídě, která rys zavádí).
	\begin{scalacode}[Příklad \textit{traits} v jazyce Scala, převzato z~\url{https://en.wikibooks.org/wiki/Scala/Traits}]
trait Person {
	var name: String
	var gender: Gender
	def sendEmail(subject: String, body: String): Unit
}

class Student extends Person {
	var name: String // "Implementation" of name
	var gender: Gender
	def sendEmail(subject: String, body: String): Unit = {
		// ...
	}
}
	\end{scalacode}

	\item Jazyk C++ nemá přímou syntaktickou podporu pro \textit{traits}, ale díky šablonám se dají použít jako návrhový vzor.
	\begin{cppcode}[Aplikace konceptu \textit{traits} v jazyku C++] $\label{traits:1}$
// ---------------- Area.h		
template< typename T >
struct hasTrait_area { static const bool value = false; };

template<typename T>
double area_calculateArea( const T &t ) {
	throw;
}

// ----------------  Circle.h
class Circle {
	public: double x = 0, y = 0, radius = 1;
};

// Definition of trait 'area' for class Circle, possibly in another module
template<>
struct hasTrait_area<Circle> { static const bool value = true; };

template<>
double area_calculateArea<Circle>( const Circle &c ) {
	return c.radius * c.radius * PI;
}

// ----------------  main.c
#include <Circle.h>
#include <iostream>

template< typename T >
void printVariableProperties( const T& var ) {
	std::cout << "Variable properties:\n";
	
	if( hasTrait_area<T>::value )
		std::cout << "  area: " << area_calculateArea( var ) << "\n";
}

void main() {
	C c;
	printVariableProperties( c );
}
	\end{cppcode}

	\item Jazyk D nabízí širší možnosti. \textit{Uniform Function Call Syntax}\cite{BrightUFCS} (dále UFCS), která pro statické funkce s alespoň jedním parametrem, které jsou standardně volány pomocí syntaxe \inlineDCode{foo( arg1, arg2, arg3 )}, připouští alternativní syntaxi volání \inlineDCode{arg1.foo( arg2, arg3 )} (funkce se pak jeví jako třídní), umožňuje využití konceptu \textit{traits} se syntaktickým zápisem, který je bližší standardnímu využití:
	\begin{dcode}[Aplikace konceptu \textit{traits} v jazyce D]
// area.d
enum bool hasTrait_area( T ) = __traits( hasMember, T, "hasTrait_area" );

// circle.d
struct Circle {
	
public:
	// Trait 'area' for Circle defined inside the object
	enum hasTrait_area = true;
	double x = 0, y = 0, radius = 1;
	double area() const {
		return radius * radius * 3.14159165358979;	
	}	
	
}

// rectangle.d
struct Rectangle {
	public double x = 0, y = 0, w = 1, h = 1;
}

// Trait 'area' for Rectangle defined outside the object (possibly different module)

/// 'Override' default hasTrait_area with more specific template parameter
template hasTrait_area( T : Rectangle ) if( is( T == Rectangle ) ) {
	enum hasTrait_area = true;
}
double area( const ref Rectangle r ) {
	return r.w * r.h;
}


// main.d
void printVariableProperties( T )( const ref T var ) {
	import std.stdio;
	writeln( "Variable properties:\n" );
	
	static if( hasTrait_area!T )
		writeln( "  area: ", var.area(), "\n" );
}

void main() {
	Circle c;
	Rectangle r;
	int x;
	
	printVariableProperties( c );
	printVariableProperties( r );
	printVariableProperties( x );
}
	\end{dcode}

	V jazyce D se dá díky jeho možnostem metaprogramování implementovat například i~kontrola, zda daný typ, který o sobě tvrdí, že má zavedený daný rys (\inlineDCode{hasTrait_area!T == true}), skutečně nabízí veškerou funkčnost rysem požadovanou.

\end{itemize}

Jazyk Beast bude podporovat vícenásobnou dědičnost, která obsahuje funkčnost \textit{traits} v takové podobě, jak je zavádí jazyky Rust nebo Scala; \textit{traits} tedy nejsou potřeba.

\subsection{Uniform function call syntax (UFCS)} \label{ufcs}
Jak již bylo zmíněno v předchozím oddíle, \textit{uniform function call syntax} (dále UFCS) je přístup, kdy se volání funkcí ve formátech \inlineCode{arg1.foo( arg2, arg3 )} a \inlineCode{foo( arg1, arg2, arg3 )} považuje za ekvivalentní. Je zavedený například v jazycích D \cite{BrightUFCS} nebo Rust.

Výhoda zavedení UFCS spočívá v tom, že programátorovi je umožněno přidávat funkčnost typům i mimo jejich definice (mimo tělo \inlineCode{class C \{ ... \}}):
\begin{dcode}[Příklad využití UFCS v jazyce D]
// D
struct Circle {
	double x = 0, y = 0, radius = 1;
}

double area( const ref Circle c ) {
	return c.radius * c.radius * PI;
}

void main() {
	import std.stdio;
	
	Circle c;
	writeln( area( c ) ); $\label{ufcs:1}$
	writeln( c.area() ); $\label{ufcs:2}$
}
\end{dcode}

Bez zavedení UFCS by kód na řádku \ref{ufcs:2} nebyl platný, bylo by možné používat pouze variantu na řádku \ref{ufcs:1}. To programátora při použití funkce nutí uvažovat, jestli je definovaná v těle třídy, nebo mimo. Pokud se jedná o funkci, která má s typem jasnou souvislost (jako v našem příkladu), dá se rozdílná syntaxe považovat za nežádoucí. Přesunutí funkce do těla třídy ale nemusí být vždy vhodné řešení, když:
\begin{itemize}
	\item Funkce pracuje nad typem, jehož definici programátor nemůže upravit -- typy definované kompilátorem (\inlineCode{Int}, \inlineCode{String}) nebo knihovnami třetích stran.
	\item Funkce pracuje nad více typy současně --  pro jazyk Beast to zde znamená, že první parameter je typu \inlineCode{auto}, například funkce
	
		\begin{code}
Double area( auto? entity )
	if( entity.#type in [ Circle, Rectangle ] )
{
	// ...
}
		\end{code}
		je schopná pracovat nad typy \inlineCode{Circle} a \inlineCode{Rectangle}. Přesun funkce do těl tříd by vyžadoval duplikaci stejného kódu (toto by se v dalo řešit pomocí třídní dědičnosti).
	\item Funkce se používá pouze ve specifických případech; například se nám v některém z~modulů hodí funkce \inlineCode{Bool isDividableByTwo(Int x)}, zavádět ji ale všude by bylo nepraktické.
\end{itemize}

UFCS nicméně povoluje volání funkce dvěma způsoby, což narušuje jednotnost kódu. V~úvahu připadá zavést direktivu kompilátoru (formou dekorátoru, viz \autoref{decorators}), která by říkala, že místo "klasické" syntaxe využívá funkce k volání syntaxi pro třídní metody. Pro každou funkci by vždy byl povolen jen jeden ze způsobů volání. Podobně fungují například \textit{extension methods} v C\#.

Jazyk Object Pascal řeší tento problém pomocí tzv. \textit{helper objects}. Objekt, nad kterým funkce pracuje, pak není předáván jako první parametr, ale napodobuje se objektový přístup (\inlinePascalCode{self} a implicitní přístup do jmenného prostoru objektu).
\begin{pascalcode}
TObjectHelper = class helper for TObject
	function Test(): String;
end;

function TObjectHelper.Test(): String;
begin
	Result := 'This is a test';
end;

var
	o: TObject;
begin
	Writeln( o.Test() );
end.
\end{pascalcode}

Tento koncept se podobá \textit{traits} popsaným v předchozím oddílu, je tu však rozdíl: zatímco v \textit{traits} je zavedeno jednotné rozhraní napříč typy a to je potom pro každý typ implementováno, \textit{helper objects} nezavádí žádné jednotné rozhraní, pouze funkčnost.

Jazyk Beast cílí zavést obdobnou funkčnost, z časových důvodů je však její zavedení a~určení přesné finální podoby odloženo.

\subsection{Standardní knihovna}
Standardní knihovna je velice důležitý prvek jazyka. Standardizace nejpoužívanějších programovacích vzorů, struktur a funkcí přispívá jak ke kompatibilitě knihoven v jazyce napsaných, tak k celkovému komfortu psaní. Vyhotovení dostatečně obsáhlé standardní knihovny je dlouhodobým cílem vývoje.

\subsection{Kompatibilita s jinými jazyky}
Pro jazyky všeobecně a pro nové jazyky obzvláště je důležitá možnost využití kódu napsaného v jiném jazyku. Pro kompilované jazyky to znamená zejména poskytnout možnost deklarovat funkce v různých volacích konvencích \cite{Wiki_CallingConvention} a s různým \textit{name mangling} \cite{Wiki_NameMangling} a poskytnout typy kompatibilní napříč jazyky. Rozbor tohoto tématu je však mimo rámec této práce.

%TODO pattern matching

\section{Nové a netypické koncepty}
Jazyk Beast také zavádí několik inovativních prvků; některé z nich jsou zmíněny v této podkapitole.

\subsection{Konstrukce \inlineCode{:ident}} \label{colonIdent}
Výčty (\textit{enums}) jsou v programovaní běžně rozšířené a poměrně hojně používané. V jazyce C neměly výčty vlastní jmenný prostor, což vedlo ke kolizím jmen. To se řešilo například přidáním prefixu před identifikátory položek, čímž nabývaly na velikosti, znepřehledňovaly kód a zpomalovaly jeho psaní. Prefixy, které odpovídaly zkratkám názvů výčtů (například \inlineCppCode{enum Month} -> \inlineCode{mJanuary}), zase často kolidovaly s prefixy jiných výčtů (například \inlineCppCode{mJanuary} a \inlineCppCode{mRead} z \inlineCppCode{enum MemoryAccess}). C++ nabízí možnost vytvořit výčet s vlastním jmenným prostorem (\inlineCppCode{enum class X}), ale to je prakticky ekvivalentní s přidáním prefixu.

Za příklad si vezměme C++ kód na zápis do souboru pomocí standardní knihovny:
\begin{cppcode}[Příklad použití výčtů v jazyce C++, převzato z~\url{http://www.cplusplus.com/reference/fstream/fstream/open/}, upraveno]
// C++
#include <fstream>
int main () {
	std::fstream fs;
	fs.open( "test.txt", std::fstream::in | std::fstream::out | std::fstream::app ); $\label{colonIdent:1}$
	fs << " more lorem ipsum";
	fs.close();
	return 0;
}
\end{cppcode}

Zde na řádku \ref{colonIdent:1} musí programátor napsat prefix \inlineCppCode{std::fstream::} dokonce třikrát. Přitom funkce \inlineCppCode{std::fstream::open} přijímá právě jenom hodnoty z tohoto výčtu (sémanticky to zcela zřejmé není, protože C++ standardně nenabízí typ, který by dokázal bezpečně pracovat s prvky výčtu jako s příznaky; jazyk Beast to však bude umožňovat).

Jazyk Beast nabízí elegantní řešení tohoto problému. Zavádí konstrukci \inlineCode{:ident}, která vyhledává zadaný identifikátor ne v aktuálním jmenném prostoru, nýbrž ve jmenném prostoru typu, jehož hodnotu kompilátor očekává. Za předpokladu, že funkce \inlineCode{open} přijímá jako druhý parametr typ \inlineCode{Flags(OpenMode)}, kde \inlineCode{OpenMode} je výčet, a že prvky výčtu jsou z příznakového typu dostupné (toho je docíleno pomocí importu rámců, viz \autoref{scopeImport}), může ekvivalentní kód v jazyce Beast vypadat takto:

\begin{code}
Void main() {
	File( "test.txt", :write | :append ).write( " more lorem ipsum" );
}
\end{code}

\subsection{Import rámce} \label{scopeImport}
Tento prvek jazyk Beast převzal z jazyka D, kde je znám jako \inlineDCode{alias this}\footnote{Více o \inlineDCode{alias this} v jazyce D na adrese \url{http://dlang.org/spec/class.html\#AliasThis}}. Typ, v jehož těle je tato konstrukce použita, se pak efektivně stává subtypem typu hodnoty \inlineDCode{expr}, která je vyhodnocena výrazem v konstrukci \inlineDCode{alias expr this} -- je do něj implicitně přetypovatelný, má přístup k jeho členům, atp.

\begin{dcode}[Příklad konstrukce \inlineDCode{alias this} v jazyce D, převzato z~\url{http://dlang.org/spec/class.html\#AliasThis}, upraveno]
// D
struct S
{
	int x;
	alias x this;
}

int foo(int i) { return i * 2; }

void test()
{
	S s;
	s.x = 7;
	int i = -s;  // i == -7
	i = s + 8;   // i == 15
	i = foo(s);  // implicit conversion to int
}
\end{dcode}

Jazyk Beast tuto konstrukci také cílí zavést, její přesná syntaktická podoba ale ještě není rozhodnutá a zavedení nebude v rámci této práce.

\subsection{Znak \inlineCode{\#} v identifikátorech}
Jazyk Beast zavádí relativně velké množství kompilátorem definovaných vlastností a členů tříd (funkce pro přetěžování operátorů, konstruktor/destruktor, funkce pro přetypování, prvky poskytující reflexi jazyka, ...). Aby se neomezovala množina identifikátorů, které programátor může použit, všechny identifikátory, které využívá kompilátor nebo které slouží k~reflexi jazyka, začínají znakem \inlineCode{\#}. Tento prostor identifikátorů je dostupný i programátorovi, nicméně jeho doporučené využití se omezuje na výše uvedené.

\begin{code}
class C {

@public:
	Void #ctor() {
		// Constructor	
	}

	Void #opBinary( Operator.binPlus, C? other ) {
		// Overload of a + b
	}

	Int foo() {
		foo.#returnType	result = 3; // Language reflection example
		return result;
	}
	
}
\end{code}

\subsection{Ternární operátor} \label{ternary}
Narozdíl od jazyků C++ a D Beast neposkytuje ternární operátor \inlineCppCode{a ? b : c}. Hlavním důvodem byla potřeba využít lexémy \inlineDCode{?} a \inlineDCode{:} jinde. Místo toho existuje funkce:

\begin{code}
auto select(@lazy Bool cond1, @lazy auto val1, @lazy auto defVal)
\end{code}
která má stejnou funkčnost (\inlineCode{cond1} odpovídá parametru \inlineDCode{a}, \inlineCode{val1} parametru \inlineDCode{b} a \inlineCode{defVal} parametru \inlineDCode{c}). Tato funkce je navíc rozšiřitelná o libovolný počet podmínek a odpovídajících hodnot -- tedy například:

\begin{code}
auto select(
	@lazy Bool cond1, @lazy auto val1,
	@lazy Bool cond3, @lazy auto val2,
	@lazy Bool cond3, @lazy auto val3,
	@lazy auto defVal
	)
\end{code}
Návratová hodnota této funkce odpovídá první hodnotě parametru \inlineCode{valX}, jehož podmínka \inlineCode{condX} je vyhodnocena jako pravda. Vyhodnocování podmínek i výrazů je líné, funkčnost tedy odpovídá zřetězenému použití ternárního operátoru.

Protože pokročilé prvky (líné vyhodnocování výrazů, variadické funkce, \inlineCode{auto} deklarace), které tato funkce vyžaduje pro implementaci, nebudou v rámci tohoto projektu implementovány (ačkoli v hotové verzi jazyka se s nimi počítá), ani samotná funkce \inlineCode{select} nebude v~demonstračním kompilátoru obsažena.

%\subsection{Konstrukce \inlineCode{switch}}

\subsection{Vnořovatelné komentáře}
Na rozdíl od jazyků C++ a Java jazyk Beast umožňuje vnořování víceřádkových komentářů \inlineCode{/* comment */}. Nebyly nalezeny žádné důvody, které by mluvily v neprospěch této vlastnosti, zatímco přínos je zřejmý -- víceřádkové komentáře se hojně používají při "zakomentovávání" kusů kódu (většinou pro testovací účely). Pokud chce programátor "zakomentovat" kód, který již obsahuje zakomentovaný kód, naráží na problém a musí odstranit zavírací "závorky" \inlineCode{*/} vnořených komentářů. Při odkomentování vnějšího bloku je situace ještě horší, protože programátor musí přemýšlet, na jaká místa má znovu přidat zavírací "závorky" vnitřních komentářů.

Jazyk D vnořené komentáře podporuje, ale mají vlastní syntaxi (\inlineDCode{/+ comment +/}).

%\subsection{Řetězcové literály}

\subsection{Předdefinované typy}
Jazyk Beast se snaží přisuzovat co největší sémantiku typům, které v základu nabízí. Z~tohoto důvodu odděluje \inlineCode{IntXX} a \inlineCode{BinaryXX} (kde \inlineCode{XX} označuje velikost typu v bitech), kde typy \inlineCode{IntXX} nepodporují bitové operace. Pro bitová pole (příznaky) jazyk nabízí typ \inlineCode{Flags(@ctime Type SourceEnum)}, který umí ideálně pracovat nad konkrétním výčtem; práce s bity by tedy měla být potřeba jen v minimu případů.

Jako náhradu za \inlineCppCode{size_t} nabízí jazyk bezznaménkové typy \inlineCode{Index} a \inlineCode{Size}. \inlineCode{Index} je zamýšlen k užití pro ukládání pozic prvků a \inlineCode{Size} pro ukládání informace o velikosti (např. seznamů). V souladu s touto sémantikou byla zavedena následující pravidla:
\begin{itemize}
	\item \inlineCode{Size}, \inlineCode{Index} a \inlineCode{IntXX} jsou mezi sebou explicitně přetypovatelné.
	\item \inlineCode{Size * IntXX = Size}, obdobně pro \inlineCode{Index}, operátory \inlineCode{\- * /} a prohozené operandy.
	\item \inlineCode{Size + Size = Size}, totéž pro \inlineCode{Index} a operátory \inlineCode{\- * /} (indexy však nelze násobit a~dělit jiným indexem).
	\item \inlineCode{Index - Size = Index}, totéž pro prohozené operandy.
	\item \inlineCode{Size - Index} nelze.
	\item \inlineCode{Index - Index = Size}
	\item \inlineCode{Pointer(Void) - Pointer(Void) = Size}
	\item \inlineCode{Pointer(X) - Pointer(X) = Index} pro ostatní typy ukazatelů
	\item \inlineCode{null} je implicitně přetypovatelné jak do typu \inlineCode{Index}, tak do \inlineCode{Size} a odpovídá hodnotě \inlineCode{\-1}.
\end{itemize}

\subsection{Konstrukce \inlineCode{while-else}} \label{design:whileElse}
Tuto konstrukci přejímá Beast z Pythonu\footnote{\url{https://docs.python.org/3/reference/compound_stmts.html\#the-while-statement}}. Konstrukce umožňuje za příkaz cyklu (\inlineCode{while}, \inlineCode{for}, ...) přidat větev \inlineCode{else}, která se vykoná, pokud cyklus není přerušen příkazem \inlineCode{break} (případně výjimkou, návratem z fuknce, atp.). Toto je užitečné například pokud cyklus implementuje vyhledávání -- v případě nálezu se použije příkaz \inlineCode{break}, který cyklus přeruší (prvek byl nalezen, další vyhledávání není potřeba) a větev \inlineCode{else} se nevykoná. Pokud cyklus prvek nenalezl, větev \inlineCode{else} poskytuje alternativní chování. Bez existence této konstrukce by se po cyklu musela použít podmínka, což je výpočetně dražší -- s konstrukcí \inlineCode{else} je to zadarmo, pouze se upraví adresy skoků.

\begin{code}
Void main() {
	String[] list = [ "the", "quick", "brown", "fox", "jumped" ];
	foreach( String item; list ) {
		if( item == "quick" )	{
			console.write( "Found!" );
			break;
		}
	} else
		console.write( "Not found!" );
}
\end{code}

\subsection{Parametry s konstantní hodnotou}
V jazyce Beast se dá specializace "šablon" provést pomocí konstrukce \inlineCode{if( expr )} (viz \autoref{metaprogramming}), která umožňuje specializaci jak částečnou (pro libovolně určenou množinu hodnot \ctime parametrů), tak pro úplnou (pro jednu konkrétní hodnotu \ctime parametrů). Úplná specializace se dá v Beastu realizovat i jednodušším způsobem -- použitím parametru s konstantní hodnotou.

\begin{code}
// Without const-value parameter
Void foo( @ctime Int x )
	if( x == 3 ) 
{
	...
}

// With const-value parameter
Void foo( 3 ) {
	...
}
\end{code}

Obě varianty se pak dají volat pomocí \inlineCode{foo( 3 )}.

Tento koncept je také užitečný k rozlišování mezi více přetíženími funkce, které mají stejně typy parametrů:

\begin{code}
class Stream {
	
	@public:
	Void #ctor( CreateFrom.fromFile, String filename ) { /* ... */ }
	Void #ctor( CreateFrom.fromString, String str ) { /* ... */ } 
	
}

Void main() {
	Stream str1 = Stream( :fromFile, "file.txt" );
	Stream str2 = Stream( :fromString, "asdfgh" );
}
\end{code}

%TODO scope guards
%TODO break labels

\chapter{Koncept líhnutí kódu (\textit{code~hatching})} \label{ctime}
Koncept líhnutí kódu je nový koncept vytvořený v rámci návrhu jazyka Beast a spojuje do koherentního celku funkčnost několika již zavedených konceptů -- například šablonového metaprogramování, reflexe jazyka, vykonávání funkcí za doby kompilace.

Koncept zavádí jednu jednoduchou myšlenku, ze které pak vyplývá celá řada důsledků. Tou myšlenkou je \textbf{zavedení klasifikátoru pro proměnné, jejichž hodnota se dá zjistit} bez nutnosti spouštět program. Tímto klasifikátorem je v~jazyce Beast dekorátor \ctime.

Vykonávání kódu tak probíhá ve dvou fázích -- hodnoty proměnných označených dekorátorem \ctime jsou odvozeny již za doby překladu, zbytek je vypočítáván za běhu samotného programu. \textbf{Toto se dá připodobnit k líhnutí vajec}, kdy se zárodek vyvíjí za skořápkou, ukryt před světem, a světlo světa spatří až jako vyvinutý jedinec.

\section{Dedukce axiomů}
Máme vyřčenou základní myšlenku -- hodnoty proměnných označených dekorátorem \ctime musíme být schopni odvodit již během kompilace; v následujícím textu tuto myšlenku budeme rozvádět. Začneme jednoduchým příkladem:

\begin{code}
@ctime Int x = 8;
\end{code}

Zde je vše jasné. Proměnná je konstantní, takže se nemůže měnit; po celou dobu její existence je její hodnota osm.

\subsection{Datové závislosti} \label{ctimeDataDependency}
Další jednoduchý příklad:

\begin{code}
@ctime Int x = console.read( Int );
\end{code}

Zde je zřejmé, že proměnná \inlineCode{x} nesplňuje naše požadavky. Příkaz \inlineCode{console.read( Int )} čte data z konzole a návratová hodnota této funkce se nedá zjistit bez spuštění programu (mohli bychom požádat o vstup již během kompilace, pro demonstraci konceptu ale toto nyní neuvažujme). Z~příkladu vyplývá, že \ctime proměnná nemůže být datově závislá na volání alespoň některých funkcí.

\begin{code}
Int add( Int x, Int y ) {
	return x + y;
}

Void main() {
	@ctime Int a = add( 5, 3 );
}
\end{code}
V tomto příkladě lze hodnotu proměnné \inlineCode{a} určit. \ctime proměnné tedy můžou být datově závislé na volání funkcí, ale jen některých.

\begin{code}
Int foo( Int x ) {
	if( x < 3 )
		return console.read( Int );

	return x + 1;
}

Void main() {
	@ctime Int a = foo( 5 );
	@ctime Int b = foo( 3 );
}
\end{code}

Tento příklad ukazuje, že to, zda funkci lze použít pro výpočet hodnot \ctime proměnných, může záležet na předaných parametrech.

\textbf{Funkce tedy k výpočtu hodnot \ctime proměnných všeobecně mohou být použity.} To, jestli funkce opravdu lze použít, se zjistí až během vykonávání. Nelze použít žádné funkce, u kterých kompilátor nezná chování nebo které závisí na externích datech (soubory, čas, vstup uživatele, ...).

Z tohoto úhlu pohledu nemá funkce smysl označovat dekorátorem \inlineCode{@ctime}; níže v této kapitole je popsáno, že se tento dekorátor na funkce používá, ale s~trochu jiným účelem.

Všeobecně se dá říci, že \ctime proměnné nemohou být závislé na \nonctime datech. Hodnoty \nonctime proměnných mohou sice být odvoditelné bez nutnosti spuštění programu, ale nemusí. Teoreticky by bylo možné klasifikátor vynechat a odvozovat jej pouze z~kódu, toto by však vyžadovalo implementaci rozsáhlé statické analýzy, která je mimo rámec možností autora. Zavedení klasifikátoru, který \ctime proměnné jasně označuje, řeší problém bez nutnosti mít statickou analýzu; navíc by se dalo spekulovat nad rozdílem čitelnosti kódu bez \ctime dekorátoru a s ním.

Předpokládejme tedy, že \textbf{hodnoty všech proměnných, které nejsou \ctime, se před spuštěním programu nedají odvodit.}

\subsection{Konstantnost}
Nyní zauvažujme nad tím, co se stane, když budeme chtít měnit hodnoty \ctime proměnných:

\begin{code}
@ctime Int! x = 8;
/* code here */
x += 2;
/* code here */
\end{code}

Zde je všechno v pořádku. \ctime proměnné tedy nemusí být vždy konstantní.

\begin{code}
@static @ctime Int! x = 5;

Void foo() {
	@ctime Int! y = 5;
	console.write( x, y, '\n' );
	y += 3;
	x += 3;
	console.write( x, y, '\n' );
}

Void foo2() {
	x += 2;
}

Void main() {
	while( true ) {
		if( console.read( Int ) < 2 )
			foo();
		else
			foo2();
	}
}
\end{code}

Tady už narážíme na problém. Za doby kompilace nemůžeme zjistit hodnotu proměnné \inlineCode{x}, protože se mění na základě uživatelského vstupu (podle výsledku \inlineCode{console.read(Int)} se totiž volá buď funkce \inlineCode{foo} nebo \inlineCode{foo2}, obě manipulují s proměnnou \inlineCode{x}). Nekonstantní statické proměnné se nedají ohlídat (a vzniká problém s pořadím vykonávání funkcí, které by s nimi manipulovaly), \textbf{\ctime statické proměnné tedy musí být vždy konstantní}.

\subsection{Podmínky a cykly}
Větvení \textit{if-then-else} a cykly sdílejí stejný princip -- různé chování na základě hodnoty nějakého výrazu. Pravidla odvozená v tomto oddílu platí pro všechna větvení stejně.

\begin{code}
Void main() {
	@ctime Int! x = 5;
	
	while( x < 6 ) $\label{ctime:branch:1}$
		x += 3;

	Int y = console.read( Int );
	if( y < 2 ) $\label{ctime:branch:2}$
		x += 8;
}
\end{code}

Z řádku \ref{ctime:branch:1} je patrné, že větvení v rámci \ctime proměnných je možné. Řádek \ref{ctime:branch:2} zase ukazuje, že to není možné vždy. Pokud je větvení datově závislé na výrazu, jehož hodnota se dá odvodit za doby kompilace (dále jen \ctime výrazu), mohou být v jeho těle přítomny \ctime proměnné. Pro usnadnění práce kompilátoru a zpřehlednění kódu Beast vyžaduje, aby \ctime větvení byly označeny dekorátorem (jinak se k nim přistupuje jako k \nonctime, viz dále).

Problematika je ale trochu složitější: \nopagebreak

\begin{code}
Void main() {
	@ctime Int! y = 6;

	while( console.read( Int ) < 5 ) {
		@ctime Int! z = 3;
				
		console.write( y );	$\label{ctime:branch:3}$
		console.write( z );
		
		z += 4;
		console.write( z + y );
		
		y += 2;
	}
}
\end{code}

Zde máme proměnnou \inlineCode{z}, která je definovaná v těle \nonctime cyklu. Nicméně takovéto použití proměnné naše požadavky nenarušuje, stejně tak čtení z proměnné \inlineCode{y} na řádku \ref{ctime:branch:3}. V \nonctime větveních tedy mohou být použity \ctime proměnné a dokonce i definovány nekonstantní \ctime proměnné. Pravidlo, které se z tohoto příkladu dá vyvodit, je že \textbf{v~tělech \nonctime větvení nelze měnit hodnoty \ctime proměnných deklarovaných mimo něj.}

\subsection{Tranzitivita \ctime}
Je zřejmé, že je-li proměnná \ctime programátorem definovaného třídního typu, musí být pro danou proměnnou všechny třídní proměnné toho typu také \ctime.

\begin{code}
class C {
	@public Int x, y;
}

Void main() {
	@ctime C c;
	c.x = 5; // c.x is @ctime
}
\end{code}

\subsection{Reference a dynamické alokace} \label{ctime:ref}
Pro praktickou demonstraci tohoto problému je již třeba složitější příklad: \nopagebreak

\begin{code}
class BinaryTreeNode {
	
@public:
	String key;
	Int! value;
	BinaryTreeNode!?! left, right;
	
}
	
class BinaryTree {

@public:
	BinaryTreeNode!?! root;
	
@public:
	Void insert!( String key, Int value ) { ... }
	
	/// binaryTree[ "key" ] key lookup
	Int #index( String key ) { ... }

}

BinaryTree sampleTree() {
	BinaryTree result;
	result.insert( "beast", 3 ); $\label{ctime:ref:2}$
	result.insert( "best", 5 ); $\label{ctime:ref:3}$
	
	result.top.data = 10;
}

@static @ctime BinaryTree tree = sampleTree(); $\label{ctime:ref:1}$

Void main() {
	console.write( tree["beast"] ); // the tree is @ctime, so the compiler is capable of looking up value in the binary tree at compile time, making this code extremely fast when running
	
	tree.root.value = 7; // tree is const, but tree.root is not $\label{ctime:ref:4}$
}
\end{code}

Zde jsme si na řádku \ref{ctime:ref:1} definovali \ctime proměnnou \inlineCode{tree}.  Třída \inlineCode{BinaryTree} potřebuje pro svou správnou funkčnost i bloky dynamicky alokované paměti (uzly stromu; v~kódu to explicitně uvedeno není, nicméně z jeho sémantiky to vyplývá). Ty pro správnou funkčnost stromu také musí splňovat podmínky \ctime. Ačkoli by teoreticky bylo možné mít \ctime ukazatel na \nonctime paměť (za doby kompilace by se vědělo, kam ukazatel odkazuje, ale ne, co v paměti je), výhodnější je udělat \ctime tranzitivní i přes ukazatele a reference. Pokud bychom to takto nenastavili, kód příkladu tohoto oddílu by pro fuknčnost vyžadoval zvláštní úpravy, nebo by nemohl fungovat vůbec.

Protože \inlineCode{tree} je statická \ctime proměnná, musí být konstantní. Dynamicky alokované bloky (uzly stromu) vytvořené při její inicializaci tedy také musí být konstantní. Toto ale neplatí zcela -- během inicializace proměnné \inlineCode{tree} (během vykonávání funkce \inlineCode{sampleTree} za doby kompilace) s bloky normálně manipulujeme (řádky \ref{ctime:ref:2} a \ref{ctime:ref:3}). Tyto bloky se tedy stávají konstantními až \textit{po} dokončení inicializace. Zde vyvstává problém -- v naší třídě \inlineCode{BinaryTree} je ukazatel na dynamicky alokovaný blok typu \inlineCode{BinaryTreeItem!?!} -- odkazovaná paměť je mutabilní. Řádek \ref{ctime:ref:4} je tedy technicky korektní, i když by podle výše uvedených myšlenek neměl být.

Jak tedy zajistit, aby se po inicializaci proměnné \inlineCode{tree} nedalo k jejím uzlům přistupovat přes mutabilní reference? Tento problém by se dal vyřešit zavedením vynucené tranzitivity konstantnosti referencí a ukazatelů -- tedy že při konstantní referenci/ukazateli by se odkazovaná paměť automaticky brala jako také konstantní. V oddílu \ref{constPropagation} jsme ale rozhodli, že jazyk Beast nebude vynucovat propagaci konstantnosti přes reference -- programátor si ji musí zajistit sám tam, kde je to potřeba. U binárního stromu je logické, že je-li konstantní strom, měly by jeho uzly být také konstantní; v případě programátorem definovaných typů ale nelze zaručit, že je mutabilita korektně ošetřena.

Při kompilaci se konstantní statické proměnné v některých kompilátorech umísťují do tzv. \textit{.text section} ve výsledném binárním souboru. Stránky paměti načtené z těchto sekcí jsou chráněny operačním systémem proti zápisu a pokus o zapsání do nich vyvolává běhovou chybu (\textit{segfault/access violation}). Beast řeší problém obdobným způsobem -- při pokusu o~zápis do paměti (během kompilace), která byla alokována během inicializace statické \ctime (nebo i jen konstantní) proměnné, mimo dobu inicializace zmíněné proměnné vyvolá kompilátor chybu. Dalším prvkem ochrany je zákaz existence mutabilních referencí a ukazatelů na dané bloky mimo rámec inicializované proměnné. Této problematice se také věnuje \autoref{sec:sessions}.

\subsection{Konverze na \nonctime}
Je vhodné objasnit, že dekorátor \inlineCode{@ctime} není modifikátor typu (\inlineCode{typeModifier}\footnote{\BeastRef{Decoration contexts}}), ale modifikátor proměnné/parametru (\inlineCode{parameterModifier}/\inlineCode{variableModifier}). To znamená, že typy proměnných \inlineCode{ref} a \inlineCode{cref} v příkladu \ref{ctime:nonctime:3} jsou shodné (\inlineCode{ref.#type == cref.#type == Int!?}). Zákaz přiřazování výrazů závislých na \nonctime datech do \ctime proměnných je řešen jinak než typovou kontrolou.

\begin{code}[\label{ctime:nonctime:3}]
Void main() {
	@ctime Int! x = 3;
	
	@ctime Int!? cref := x;
	cref = 9; $\label{ctime:nonctime:1}$
	
	Int!? ref := cref; $\label{ctime:nonctime:2}$
	
	if( console.read( Int ) < 5 )
		ref := 8; // x = 8 based on console.read!
		
	@ctime Int y = x;
}
\end{code}

Výše uvedený příklad neporušuje žádné z pravidel, které jsme si již odvodili, nicméně hodnota proměnné \inlineCode{y} již není odvoditelná během kompilace, protože se hodnota proměnné \inlineCode{x}~může změnit na základě uživatelského vstupu. Přiřazení do \inlineCode{cref} na řádku \ref{ctime:nonctime:1} je v pořádku; kontrola nad daty se ztrácí při inicializaci proměnné \inlineCode{ref} na řádku \ref{ctime:nonctime:2}. Aby se tomuto předešlo, zavedeme pravidlo, že \textbf{na \ctime data nelze odkazovat \nonctime referencí/ukazatelem na mutabilní typ}.

Toto pravidlo ale není dostatečné:

\begin{code}
class C {
	@public Int! x;
}

class D {
	@public C!?! c = new C;
}

Void main() {
	@ctime D d;
	
	D? dref := d;
	dref.c.x = 5; // Changing @ctime data via non-@ctime reference!
}
\end{code}

Zde jsme toto pravidlo neporušili, ale přesto se nám opět podařilo porušit axiom pro \ctime. Zavedeme tedy další pravidlo: \textbf{odkaz na \ctime data nelze uložit do \nonctime reference/ukazatele, pokud všechny třídní proměnné typu reference/ukazatel v~odkazovaném typu nejsou konstantní}.

Toto pravidlo se ale také dá obejít:

\begin{code}
class C {
	@public Int x;
}

class C2 : C {
	@public Int!? y = new Int;
}

class D {
	@public C? c = new C2;
}

Void main() {
	@ctime D d;
	
	D? dref := d;
	dref.c.to( C2? ).y = 5;
}
\end{code}

Řešení tohoto problému už je značně problematické. Kvůli způsobu implementace by zápis do paměti připadající \ctime datům vedl k nedefinovanému chování aplikace, takže je třeba mu zabránit. Všem těmto komplikacím by se předešlo vynucením tranzitivity konstantnosti přes referenci a vzniká tak dilema, zda tranzitivitu vynutit i za cenu omezení možností programátora, nebo ponechat programátorovi místo, kde by se nechtěně mohl "střelil do nohy". Na základě názoru, že "jazyk má sloužit programátorovi, ne programátor jazyku" se autor přiklání k variantě nevynucovat tranzitivitu.

\subsection{Třídní \ctime proměnné}
Zvažme možnost existence nestatických \ctime proměnných ve třídách: \nopagebreak

\begin{code}
class C {
	
@public:
	@ctime Int! y = 0;
	
@public:
	Void foo!() {
		y += 3;
	}
	
}

Void main() {
	C! c, c2;
	
	C!?! cref = select( console.read( Int ) < 4, c, c2 );
	cref.foo();
}
\end{code}

Z příkladu lze odvodit, že myšlenka není uskutečnitelná. Volání funkce \inlineCode{foo} je datově závislé na uživatelském vstup a nedá se tomu zabránit jinak, než označením proměnných \inlineCode{c}~a~\inlineCode{c2} jako \ctime (což by znemožnilo použití \inlineCode{console.read}). I kdybychom zavedli "\ctimeNoXSpace" funkce, které jako parametry přijímají pouze \ctime data, k ničemu by nám to nebylo. Toto se dá chápat i tak, že funkce \inlineCode{foo} obsahuje skrytý parametr -- odkaz na instanci třídy. Protože proměnná \inlineCode{cref} není \ctime, právě tento parametr by porušoval axiom \ctime.

\section{Přehled odvozených pravidel} \label{ctime:rules}
\begin{enumerate}
	\item \ctime proměnné nemohou být jakkoli (datově) závislé na proměnných, které nejsou \ctime. 
	\item Statické \ctime proměnné musí být konstantní.
	\item Větvení může být \ctime, pokud je řídící výraz \ctime.
	\begin{enumerate}
		\item \ctime větvení se musí dekorovat.
		\item Těla \ctime větvení nejsou nijak omezena (nejsou \ctime).
		\item V tělech \nonctime větvení se nemůže měnit data \ctime proměnných, které byly deklarovány mimo něj (ale lze je číst).
	\end{enumerate}
	\item Je-li proměnná \ctime, jsou všechny její třídní proměnné také \ctime.
	\item Je-li reference nebo ukazatel \ctime, paměť, na kterou odkazuje, je také \ctime (\ctime je tranzitivní přes odkaz).
	\item Po inicializaci statické \ctime proměnné nelze zapisovat do paměti, která byla během její inicializace (dynamicky) alokována.
	\item Ukládání \ctime proměnných do \nonctime proměnných má další omezení:
	\begin{enumerate}
		\item Na \ctime data nelze odkazovat \nonctime referencí/ukazatelem na mutabilní typ.
		\item Odkaz na \ctime data nelze uložit do \nonctime reference/ukazatele, pokud všechny třídní proměnné typu reference/ukazatel v odkazovaném typu nejsou konstantní.
	\end{enumerate}
	\item Třída (\nonctime) nemůže obsahovat nestatické \ctime proměnné.
\end{enumerate}

V dalších oddílech jsou odvozena další dodatečná pravidla. Jejich přehled je uveden v~podkapitole \ref{ctime:moreRules}.

\section{Potenciál a důsledky konceptu}
Když už máme odvozená pravidla, můžeme si ukázat, co všechno nám koncept líhnutí kódu umožňuje.

\subsection{Optimalizace kódu}
Pokud kompilátor zná hodnoty \ctime proměnných již za doby kompilace, logicky může výpočet jejich hodnot vynechat při běhu. Kód

\begin{code}
Void main() {
	@ctime Bignum myPrime = nthPrimeNumber( 1286345 );
	console.write( myPrime );
}
\end{code}

se vyoptimalizuje do

\begin{code}
Void main() {
	console.write( 20264747 );
}
\end{code}

Toto samozřejmě umí hodně moderních kompilátorů; dekorátor \inlineCode{@ctime} ale dává programátorovi pevnější kontrolu nad optimalizacemi.

\subsection{Typové proměnné} \label{ctime:typeVars}
Díky tomu, že kompilátor zná hodnotu \ctime proměnné v každém bodě již během kompilace, může měnit chování \ctime proměnné na základě její hodnoty. To umožňuje zavedení mutabilních typových proměnných. Všechny třídy jsou v jazyce Beast instancemi třidy \inlineCode{Type} (i samotná třída \inlineCode{Type} je svou vlastní instancí). Identifikátory tříd jsou ekvivalentní konstantním typovým proměnným.

\begin{code}
Void main() {
	@ctime Type T = Int16;
	
	@ctime if( VERSION > 15 )
		T = Int32;
		
	T x = 4;
}
\end{code}

\begin{code}
class C {
	@static Int! x;
}

class D {
	@static Int! y;
}

void Main() {
	@ctime Type T = C;
	T.x = 5;
	
	T = D;
	D.y = 8;
}
\end{code}

Typová proměnná může existovat pouze jako \ctime.

\subsection{Šablonování a unifikace šablonových a klasických parametrů}
Koncept \ctime se dá jednoduše využít i pro parametry šablon.

\begin{code}
class TreeNode( @ctime Type Key, @ctime Type Value, @ctime Int childrenCount ) {
	
@public:
	Key! key;
	Value! value;
	This?!?[ childrenCount ] children;
	
}
\end{code}

Díky prakticky nulovému rozdílu v syntaxi \ctime a \nonctime proměnných lze šablonové a standardní parametry funkcí zapisovat do stejných závorek a libovolně je míchat:

\begin{code}
T readFromBuffer( Buffer!? buf, @ctime Type T ) {
	T? result = buf.ptr.to( T? );
	buf.ptr += T.#size;
	return result;
}

Void main() {
	Buffer! buf;
	buf.readFromFile( File( "in.txt", :read ) ); 
	Int i = readFromBuffer( buf, Int );
}
\end{code}

Dokonce lze vytvořit i speciální dekorátor, v našem jazce pojmenovaný \inlineCode{@autoCtime}, který argument bere jako \ctime, pokud to je možné: \nopagebreak

\begin{code}
Index regexFind( String data, @autoCtime String regex ) {
	// regex implementation
}

Void main() {
	Index r1 = regexFind( console.read( String ), "Y[a-z]+l" ); // Regex argument is known at compile time, so the regex precprocessing is done at compile time
	
	Index r2 = regexFind( console.read( String ), console.read( String ) ); // No optimizations here
}
\end{code}

Pomocí klíčového slova \inlineCode{auto} může funkce přijmout hodnotu jakéhokoli typu

\begin{cppcode}
// C++
template< typename T1, typename T2 >
inline auto max( T1 a, T2 b ) {
	return ( a  > b ) ? a : b;
}
\end{cppcode}

\begin{code}
// Beast
@inline auto max( auto a, auto b ) = select( a > b, a, b );
\end{code}

Jak bylo popsáno v oddílu \ref{metaprogramming}, jazyk Beast zavádí konstrukci \inlineCode{if( expr )}, která se vkládá mezi deklarační část a tělo funkce/třídy. Výraz \inlineCode{expr} je vyhodnocen jako \inlineCode{@ctime Bool} a pokud je jeho hodnota \inlineCode{false}, deklarace je ignorována. Výraz v konstrukci může pracovat i s \ctime argumenty deklarace.

\begin{code}
Void test( @ctime Int x )
	if( x < 0 )
{
	console.write( "<0" );
}

Void test( @ctime Int x )
	if( x >= 0 )
{
	console.write( ">=0" );
}

Void main() {
	test( -3 ); // Writes "<0"
	test( 5 ); // Writes ">=0"
}
\end{code}

\subsection{\ctime funkce a třídy}
Pro usnadnění práce programátora se zavádí i podpora dekorátoru \inlineCode{@ctime} pro funkce a~třídy.

\ctime funkce mají všechny argumenty, návratovou hodnotu, proměnné a příkazy uvnitř automaticky \ctime a není tedy třeba všechny prvky takto dekorovat.

Třídní proměnné \ctime tříd jsou \ctime (funkce mohou být \nonctime).

\subsection{Reflexe kódu} \label{ctime:reflection}
Koncept také umožňuje reflexi; implicitně se jedná o reflexi za doby kompilace, reflexi za doby běhu si programátor může napsat (případně využít knihovnu). Vezmeme-li v úvahu, že každá třída je instancí \ctime třídy \inlineCode{Type}, stačí už jen přidat do těchto tříd další \ctime proměnné, které je popisují. Jazyk Beast zavádí \ctime konstanty jako \inlineCode{Symbol.#identifier}, \inlineCode{Function.#returnType}, třídy \inlineCode{FunctionMetadata}, \inlineCode{ClassMetadata} a funkce jako \inlineCode{Class.#member( String identifier )}, které reflexi zajišťují.

\section{Implementace konceptu} \label{ctime:orderInterpreters}
Nyní zvažme, jak by se tento koncept dal implementovat do kompilátoru.

Je zřejmé, že hodnoty \ctime proměnných se budou vypočítávat již během kompilace pomocí interpretu zabudovaného do kompilátoru.

Možnosti \ctime jsou díky \hyperref[ctime:typeVars]{typovým proměnným} a \hyperref[ctime:reflection]{reflexi kódu} větší, než co je možné udělat za běhu aplikace; v rámci \ctime se sémantika příkazů může měnit na základě vykonání jiného \ctime kódu. Kdybychom zpracování \ctime chtěli realizovat klasickým interpretem, který přijímá bajtkód, zjistili bychom, že takový kód, který by dokázal pojmout veškerou funkčnost konceptu líhnutí kódu, by odpovídal abstraktnímu syntaktickému stromu.

Tento \ctime~"interpret" bude nutně pomalejší než konvenční interprety, protože jeho součástí je kompletní sémantická analýza. Jakmile ale zpracujeme \ctime proměnné, můžeme kód převést do bajtkódu a ten vykonávat konvenčním interpretem, který je rychlejší. Pro větší rychlost kompilace by tedy kompilátor jazyka Beast měl mít dva interprety: první (dále interpret prvního stupně) pracující přímo nad AST schopný zpracovávat i~\ctime proměnné a~druhý (dále interpret druhého stupně) pracující nad bajtkódem. Tyto interprety se dokonce mohou postupně aplikovat na stejnou funkci:

\begin{code}
Int pow( Int x, @ctime Int exp ) {
	Int! result = 1;
	
	@ctime foreach( expTmp; 0 .. exp )
		result *= x;
		
	return result;
}

@ctime Int powed = pow( 5, 3 );
\end{code}

Výše uvedený kód by po interpretaci funkce \inlineCode{pow( 5, 3 )} pomocí \ctime interpretu vypadal (bez optimalizací) takto: \nopagebreak

\begin{code}
Int pow( Int x, 3 ) {
	Int! result = 1;
	result *= x;
	result *= x;
	result *= x;
	return result;
}
\end{code}

Po spuštění druhého stupně interpretace (které by předcházela generace bajtkódu) by funkce už navrátila hodnotu 125, která by se uložila do proměnné \inlineCode{powed}. V tomto konkrétním případě by mohlo být vhodnější celou funkci vykonat pomocí pomalejšího \ctime interpretu (protože generování bajtkódu a jeho následné vykonání může být ve výsledku pomalejší), nicméně v~případech, kdy by se funkce \inlineCode{pow} se stejnou hodnotou druhého parametru (který je \ctime) volala vícekrát, je výhodnější použít dvoustupňovou interpretaci.

%Bližší studium této problematiky je mimo rámec této práce. I přes faktickou existenci pouze jednoho interpretu zaveďme termíny "interpretace prvního stupně," kterým je myšleno zpracování \ctime kódu, a "interpretace druhého stupně," který referuje na vykonávání standardních funkcí za doby kompilace.

\subsection{\ctime proměnné a \nonctime reference} \label{ctime:impl:ref}
Nelze tvrdit, že \ctime proměnné jsou čistě záležitostí kompilace. V momentě, kdy uložíme adresu \ctime proměnné do \nonctime reference/ukazatele (toto může nastat například i~při předávání \ctime dat jako argumentů typu reference při volání \nonctime funkcí), tak abychom zajistili funkčnost reference, musíme data této proměnné (a všech dalších proměnných, na které odkazuje) umístit do paměti i při běhu programu. Ačkoli je veškerý \ctime kód vykonáván interpretem prvního stupně, výsledky a dokonce i některé mezistavy musí být kopírovány při běhu aplikace.

Uvažme příklad:

\begin{code}
Void write( Int? val ) {
	console.write( val );
}
	
Void main() {
	@ctime Int! x = 3; $\label{ctime:impl:ref:1}$
	write( x ); $\label{ctime:impl:ref:2}$
	x += factorial( 10 ); $\label{ctime:impl:ref:3}$
	x += 5; $\label{ctime:impl:ref:5}$
	write( x ); $\label{ctime:impl:ref:4}$
}
\end{code}

Řádky \ref{ctime:impl:ref:1}, \ref{ctime:impl:ref:3} a \ref{ctime:impl:ref:5} jsou obsluhovány interpretem prvního stupně a řádky \ref{ctime:impl:ref:2} a \ref{ctime:impl:ref:4} se vykonávají až za běhu aplikace. Vzhledem k tomu, že parametr funkce \inlineCode{write} je předáván odkazem, musí existovat místo v paměti, které je funkci předáno a které obsahuje aktuální hodnotu proměnné \inlineCode{x}. Hodnota nemusí být aktualizována vykováváním samotného výpočtu -- mašinerii pro výpočet faktoriálu lze nahradit jednoduchou \textit{mov} nebo \textit{xor} instrukcí -- a~nemusí být aktualizována vždy -- například mezi řádky \ref{ctime:impl:ref:3} a \ref{ctime:impl:ref:5} není žádný \nonctime kód, který by s~daty pracoval a není tedy třeba promítat změny z řádku \ref{ctime:impl:ref:3} okamžitě do paměti. 

\subsubsection{Paměťové prostory}
Je třeba také brát v potaz existenci dvou adresových prostorů -- virtuálního, se kterým se pracuje během kompilace, a skutečného, který je zaveden při běhu programu. Interpret v~kompilátoru nutně nemusí být implementován s klasickým adresovým prostorem, pro funkčnost ukazatelové aritmetiky v \ctime se ale jedná o nejintuitivnější řešení a demonstrační kompilátor je tímto způsobem implementován.

\begin{code}[\label{ctime:impl:ref:mem:1}]
Void foo() {
	@ctime Int! x = 3;
	@ctime Int? ctXRef := x;
	Int? xRef := x;
}
\end{code}

Ve výše uvedeném příkladu je proměnná \inlineCode{cXRef} \ctime, kompilátor tedy musí vědět, kam odkazuje. To při našem návrhu interpretu znamená, že proměnné \inlineCode{x} musí být přiřazena adresa již za doby kompilace. Nedá se předpokládat, že adresa proměnné \inlineCode{x} bude za běhu stejná jako za doby kompilace. Kromě toho za doby kompilace bude proměnná \inlineCode{x} existovat pouze v jedné instanci -- protože funkce \inlineCode{foo} není \ctime, hodnoty lokálních \ctime proměnných budou mít vždy ve stejném místě v kódu stejnou hodnotu; interpretu prvního stupně stačí vykonat \ctime část funkce pouze jednou.

Je tedy třeba zavést mapování z adresového prostoru interpretu prvního stupně do adresového prostoru aplikace, případně interpretu druhého stupně. Toto mapování může mít tři formy:
\begin{enumerate}
	\item Mapování adres statických dat (pevná adresa)
	\item Mapování adres lokálních proměnných (na zásobníku -- \textit{base pointer offset}, takto je řešená například proměnná \inlineCode{x} z příkladu \ref{ctime:impl:ref:mem:1})
	\item Mapování adres \ctime bloků, které byly dynamicky alokovány při vykonávání \nonctime funkce
\end{enumerate}

Třetí forma se dá demonstrovat tímto příkladem:

\begin{code}
Void foo() {
	@ctime Int!?! x := new Int!( 5 );
	console.write( x );
	x += 5;
	console.write( x );
	delete x;
}
\end{code}

Zde se při každém volání funkce \inlineCode{foo} dynamicky alokuje proměnná typu \inlineCode{Int}. Protože dynamická alokace je součástí inicializace \ctime proměnné, je obsluhována interpretem prvního stupně. Interpret tím pádem musí zajišťovat (generováním vhodných instrukcí) promítání změn proměnné odkazované z \inlineCode{x} do paměti běžící aplikace. V tomto konkrétním případě je jednoduché odvodit, že adresa je uložena v proměnné \inlineCode{x}, vezmeme-li ale v úvahu vícenásobnou indirekci v \ctime datech a optimalizaci promítání změn (takže změny dat jsou promítány v dávkách, až když je to potřeba -- kompilátor tedy v době promítání již "neví", přes které odkazy se k danému bloku dat dostal), problém na triviálnosti ztrácí.

Naivním řešením tohoto problému je uchovávat adresy všech bloků, které byly dynamicky alokovány při vykonávání \ctime kódu, jako skryté proměnné na zásobníku -- to ale může při větším počtu dynamických alokací způsobovat potíže s místem na zásobníku. Zkoumání efektivnějších řešení této problematiky je ale mimo rámec této práce. Demonstrační kompilátor to řeší právě uvedeným naivním způsobem.

Demonstrační kompilátor kvůli mapování adres uchovává informace o tom, na kterých místech paměti interpretu jsou ukazatelé a reference (podle volání konstruktorů a destruktorů). 

Aby se skryly rozdíly mezi adresovým prostorem interpretu a adresovým prostorem za běhu a předešlo se tak případným problémům (například by hašovací tabulka v \ctime generovala hashe na základě hodnot ukazatelů, ale za běhu by adresy byly jiné a tabulka by tím pádem byla neplatná), Beast dává \ctime ukazatelům a referencím následující omezení:
\begin{enumerate}
	\item Přetypování mezi referenčním a nereferenčním typem není možné (nelze přetypovat ukazatel/referenci na ordinální typ ani naopak).
	
	Toto se dá obejít přetypováním adresy ukazatele na Pointer( Void ) a pak na ordinální typ pomocí kódu \inlineCode{pointer.addr.to( Pointer( Void ) ).to( Pointer( Index ) ).data}, ale tomu se dá jen těžce zabránit. Takovéto přetypování programátor používá na vlastni nebezpečí.
	
	\item Provnávání (\inlineCode{< > <= >=}, lze \inlineCode{== a !=}) a rozdíl dvou ukazatelů je možný pouze pro ukazatele, které ukazují na stejný blok paměti (v jiných případech kompilátor zobrazí chybu). Toto omezení je kontrolováno interpretem při vykonávání.
\end{enumerate}

\subsection{\ctime větvení a sémantická kontrola}

Uvažme následující příklad:

\begin{code}
class C {
	Int! x;
}

class D {
	Int! y;
}
	
Void main() {
	@ctime Type T = C;
	@ctime T a;
	
	@ctime if( a.#type == C )
		a.x = 5;
	else
		a.y = 5; $\label{ctime:impl:branch:1}$
}
\end{code}

Aby kód správně fungoval, sémantická kontrola v \inlineCode{else} větvi podmínky (řádek \ref{ctime:impl:branch:1}) nesmí proběhnout, protože proměnná \inlineCode{a} nemá člen \inlineCode{y}. Tento případ není okrajovou záležitostí -- v~reálném \ctime kódu by obdobné problémy nastávaly na spoustě míst. \textbf{Sémantická kontrola tedy neprobíhá ve větvích \ctime větvení, které neproběhnou.} Na druhou stranu ale musí probíhat pro každou iteraci \ctime cyklů zvlášť: \nopagebreak

\begin{code}
class C { 
	Int! x;
}
	
Void main() {
	@ctime Type[] arr = [ Int16, Int32, C ];
	@ctime foreach( Type T; arr ) {
		T var;
		
		@ctime if( T == C )
			var.x = 5;
		else
			var = 5;
	}
}
\end{code}

\subsection{Šablonování}
Následující dva příklady mají stejný význam a podobnou funkčnost:

\begin{cppcode}
// C++
template< int i >
int foo( int j ) {
	return i * i * j;
}
\end{cppcode}

\begin{code}
// Beast
Int foo( @ctime Int i, Int j ) {
	return i * i * j;
}
\end{code}

\ctime proměnné v tomto příkladu nahrazují parametry šablon. Po doplnění hodnoty do parametru \inlineCode{i} (který je \ctime, a tedy je třeba znát jeho hodnotu již za doby kompilace; v příkladu níže \inlineCode{i = 5}), kompilátor vygeneruje funkci v podobě:

\begin{code}
Int foo( 5, Int j ) {
	return 25 * j;
}
\end{code}

V případě, že se někde jinde v kódu volá funkce \inlineCode{foo} se \textit{stejnými} \ctime argumenty, zdánlivě není třeba generovat další funkci, protože by se chovala naprosto stejně; kompilátor může využít již vygenerovaný kód. Stejnými \ctime argumenty se myslí bitově shodná data; nelze uvažovat shodu podle operátoru \inlineCode{==}, protože bitově rozdílná data mohou i~přes sémantickou shodu vést k rozdílným výsledkům výpočtu (například i když jsou dva binární stromy shodné, jejich hloubka může být různá a výsledky výpočtů pracujících s hloubkou se nemusí shodovat).

Tvrzení, že bitově stejné \ctime argumenty generují stejné funkce, ale není ve všech případech platné. Uvažme tento příklad: \nopagebreak

\begin{code}
Int calc( Int x, @ctime Int!? y ) {
	y ++;
	return x + y;
}

Void main() {
	@ctime Int! y = 1;
	Int f = 0;
	f += calc( 5, y ); $\label{ctime:impl:templ:1}$
	f += calc( 5, y ); $\label{ctime:impl:templ:2}$
}
\end{code}

Ačkoli zde funkce \inlineCode{calc} při volání na řádcích \ref{ctime:impl:templ:1} a \ref{ctime:impl:templ:2} přijímá bytově stejné \ctime argumenty, v prvním případě navrací \inlineCode{x + 2} a ve druhém \inlineCode{x + 3}. Nedá se tedy zaručit, že dvě funkce generované ze stejných \ctime argumentů budou totožné, a nejjednodušším způsobem je funkci pokaždé generovat. Na tento problém lze aplikovat řadu optimalizačních algoritmů, jejich rozvedení je ale mimo rámec této práce.

\subsection{Typové proměnné}
Typové proměnné lze z formálního hlediska považovat za typické \ctime proměnné. Jediným případem, kdy se typová proměnná liší od ostatních \ctime proměnných, je konstrukt pro deklaraci proměnné.

\begin{comment}
\subsection{Možné konflikty referencí, \ctime a CTFE}
Uvažme následující kód:

\begin{code}
Void foo( Int!? x, @ctime Int!? y ) {
	@ctime while( y < 2 ) {
		while( x < 10000 ) $\label{ctime:ctfeConflict:2}$
			x++;
		y++;
	}
}

Void main() {
	@ctime Int! a = 0;
	foo( a, a ); $\label{ctime:ctfeConflict:1}$
}
\end{code}

Funkce \inlineCode{foo} je zde na řádku \ref{ctime:ctfeConflict:1} volána za doby kompilace (protože se jí předává \ctime proměnná přes nekonstantní referenci). Uvážíme-li, že se funkce může vykonávat ve dvou stupních (v tomto případě to má smysl, protože řádek \ref{ctime:ctfeConflict:2} představuje relativně velký cyklus a interpret druhého stupně je rychlejší), vyvstává tu problém: kód po interpretaci prvního stupně bude vypadat takto:

\begin{code}
Void foo( Int!? x ) {
	@ctime while( y < 4 ) {
		while( x < 10000 )
			x++;
		// y = 1
		
		while( x < 10000 )
			x++;
		// y = 2
		
		while( x < 10000 )
			x++;
		// y = 3
	}
\end{code}

Chování funkce neodpovídá tomu, jak by se chovala při jednostupňové interpretaci. Jelikož v demonstračním kompilátoru dvoustupňová interpretace nebude, není třeba tento problém bezprostředně řešit. Řešení problému by ale mohlo vést k zavedení dalších limitujících pravidel, tedy k regresi.
\end{comment}

\section{Přehled doplňujících pravidel} \label{ctime:moreRules}
Tento přehled pravidel doplňuje ten uvedený v podkapitole \ref{ctime:rules}.

\begin{enumerate}
	\item Je zakázáno přetypovávat \ctime ukazatel na jiný než referenční \ctime typ a naopak.
	\item Nelze porovnávat (\inlineCode{< > <= >=}, lze \inlineCode{== a !=}) ani vypočítat rozdíl \ctime ukazatelů, které patří do různých alokačních bloků paměti.
	\item Pro nevykonané \ctime větve se neprovádí sémantická kontrola. U \ctime cyklů se provádí sémantická kontrola pro každou iteraci zvlášť.
\end{enumerate}

\chapter{Implementace kompilátoru} \label{chap:compiler}
Tato kapitola se věnuje implementaci demonstračního kompilátoru jazyka Beast, pojmenovaném \textit{Dragon}.

\subsubsection{Volba implementačního jazyka}
S ohledem na autorovu znalost programovacích jazyků připadaly jako jazyky pro implementaci demonstračního kompilátoru v úvahu dva kandidáti -- C++ a D. Zvítězil jazyk D, zejména kvůli obsáhlé a dobře zdokumentované standardní knihovně a kvůli odpadnutí nutnosti psát hlavičkové soubory. Nevýhodou je menší nabídka podporovaných vývojových prostředí, obzvláště pak s podporou ladění v OS Windows.

\section{Lexikální a syntaktická analýza}
Při psaní kompilátoru stojí za to uvažovat o využití generátoru parseru. Existuje mnoho generátorů parserů, jejich průzkum a srovnávání by samo o sobě vydalo na knihu; mezi ty nejznámější z nich patří například LALR generátor Bison\footnote{\url{https://www.gnu.org/software/bison/}}, a LL generátor ANTLR\footnote{\url{http://www.antlr.org/}}. Srovnání LL a LR parserů je mimo rámec této práce a~snadno dohledatelné na internetu v~přehledné podobě (například \cite{LLLRComp}).

 Bylo rozhodnuto, že demonstrační kompilátor bude založen na LL parseru, především kvůli větší intuitivnosti návrhu a lepším možnostem generování chybových zpráv. Dalším předmětem k úvaze bylo, zda opravdu použít generátor parseru, nebo parser napsat ručně. Napsání vlastního syntaktického a sémantického analyzátoru není obtížné a nejde o nic neobvyklého -- takto jsou řešeny například kompilátory Microsoft C\#\footnote{Dle \cite{JavaCompilerConstructionCampbell}, oddíl 8.5.2}, DMD\footnote{Kompilátor jazyka D; zřejmé z kódu parseru, viz \url{https://github.com/dlang/dmd/blob/master/src/parse.d}}, GCC\footnote{Uvedeno zde: \url{https://gcc.gnu.org/wiki/New_C_Parser}} nebo Clang\footnote{Uvedeno zde: \url{http://clang.llvm.org/features.html}, první odstavec předposledního oddílu}. Autor tohoto projektu zvolil variantu napsání vlastního parseru a lexeru metodou rekurzivního sestupu (modifikovanou tak, aby si poradila i s částmi gramatiky, které nejde zpracovat LL(1) parserem) ve víře, že časová náročnost bude srovnatelná s osvojením si a aplikací nové technologie s~tím, že takto napsaný parser bude lépe modifikovatelný a~všeobecně více "pod kontrolou".
 
	\section{\inlineCode{TaskGuard} -- vícevláknová implementace, \textit{poisoning}, \mbox{cyklické} \mbox{závislosti}}
Uhelným kamenem kompilátoru je třída \inlineCode{TaskGuard}, která zapouzdřuje mechanismus "úloh" (angl. \textit{tasks}), které kompilátor vykonává. Tyto úlohy jsou například:
\begin{itemize}
	\item Syntaktická analýza souboru
	\item Odvození typu statické proměnné (sémantická analýza výrazu, který popisuje typ proměnné)
	\item Vytvoření tabulky symbolů pro daný jmenný prostor ze syntaktického stromu
\end{itemize}

Každá úloha se vykonává maximálně jednou. Vykonání jedné úlohy může být závislé na jiné úloze (nebo více jiných úlohách), například vytvoření tabulky symbolů pro jmenný prostor modulu vyžaduje nejdřív vykonání syntaktické analýzy zdrojového souboru. Takto vzniká orientovaný acyklický graf závislostí jednotlivých úloh. Protože úlohy nemění stav systému, kromě dat spojených se samotnou úlohou (které jsou zbytku systému zpřístupněny až po dokončení úlohy), mohou být jednotlivé úlohy vykonávány paralelně. Kompilátor Dragon je tedy \textbf{vícevláknový}.

\putImage[Příklad grafu závislostí úloh]{taskTree.pdf}{width=11cm}

V některých případech může vzniknout cyklický graf, například v kódu

\begin{code}
a.#type b;
b.#type a;
\end{code}

Zde vzniká cyklická závislost úloh pro odvození typu proměnné \inlineCode{a} a pro odvození typu proměnné \inlineCode{b}. Třída \inlineCode{TaskGuard} je takovouto cyklickou závislost schopná detekovat a reagovat na ni vypsáním chybové hlášky.

V případě, že během vykonávání úlohy vznikne chyba (je vyvolána výjimka), třída \inlineCode{TaskGuard} si k dané úloze poznačí, že její zpracování způsobilo chybu. Tento příznak chyby se propaguje grafem závislostí do všech závislých úloh (další chybové hlášky se nevypisují). Ty části grafu, které touto chybou nejsou ovlivněny, mohou být dále zpracovávány a případně produkovat další, nezávislé chybové hlášky.

V praxi se graf závislostí tvoří postupně; vykonání jedné úlohy vytváří další úlohy, které mají být vykonány (například syntaktická analýza rozpozná definici funkce, pro kterou jsou vytvořeny úlohy pro odvození návratového typu, zpracování seznamu parametrů a generování kódu) a většina závislostí je objevena až během vykonávání nějaké úlohy (například to, že kód funkce pracuje s nějakou třídou, se zjistí až během zpracovávání daného kódu). Tomuto je přizpůsobena i implementace třídy \inlineCode{TaskGuard}.

Třída obsahuje jedinou funkci, \inlineCode{enforceDone}. Jakémukoli přístupu k datům, které úloha zpracovává, musí předcházet volání právě této funkce. Funkce se chová následovně:
\begin{itemize}
	\item Pokud byla úloha již dříve vykonána s chybou, funkce vyvolá "tichou" výjimku.
	\item Pokud je úloha již vykonaná, funkce se ukončí.
	\item Pokud úloha ještě nebyla vykonána, zavolá se funkce (předaná třídě \inlineCode{TaskGuard} jako parametr), která zajistí její vykonání. Pokud je během vykonávání této funkce vyvolána výjimka, \inlineCode{TaskGuard} ji zachytí, poznamená si, že úloha byla vykonána s chybou, a výjimku předá dál.
	\item Pokud je úloha právě vykonávána v jiném vlákně, aktuální vlákno se pozastaví a~do správy vláken se přidá záznam, aby bylo obnoveno po dokončení úlohy (na druhém vlákně). Pokud vykonání úlohy na jiném vlákně skončí chybou, je aktuální vlákno obnoveno a je na něm vyvolána tichá výjimka.
	
	Před přidáním záznamu do správy vláken je ověřeno, zda by přidáním nevznikla cyklická závislost (totiž zda vlákno A nečeká na vlákno B, které by přidáním záznamu mělo čekat na vlákno A); v~takovém případě je nahlášena chyba, všechna tato vlákna jsou probuzena a je v nich vyvolána tichá výjimka.
\end{itemize}

Implementace využívá atomických operací, k použití semaforů dochází až v případě, že je potřeba využít správu vláken. Místo systémových vláken se využívá vlákének (angl. \textit{Fibers}), což dále snižuje cenu režie.

\section{Virtuální paměť a \textit{sessions}} \label{sec:sessions}
Kompilátor zavádí virtuální adresový prostor. V něm jsou uloženy nejenom data \ctime proměnných, ale  adresy v tomto prostoru jsou přiřazeny i \nonctime proměnným. To umožňuje jednotný přístup k \ctime a \nonctime proměnným. Každý blok paměti obsahuje příznak, ve kterém je uloženo, zda blok reflektuje \ctime proměnnou nebo \nonctime proměnnou. Pokus o čtení z/zápis do \nonctime bloků během doby kompilace pochopitelně vyvolá chybu.

Virtuální paměťový prostor je z časových důvodů implementován lineárním polem; do budoucna je plánováno upuštění od klasického virtuálního adresového prostoru (kde má každý bajt unikátní adresu i na úrovni interpretovaného kódu/dat) a využití jiného způsobu implementace ukazatelů pro interpret.

Implementované řešení virtuální paměti také disponuje systémem pro ochranu zápisu -- ten je využit zejména pro vynucování dodržení pravidel konceptu líhnutí kódu. Systém je implementován pomocí tzv. \textit{sessions} a \textit{subsessions}. Jedná se o číselné identifikátory, které jsou vázané k jednotlivým vláknům kompilátoru. Při alokaci/dealokaci virtuální paměti se k bloku uloží \textit{session} a \textit{subsession id}, které jsou právě přiřazeny k vláknu, které alokaci iniciovalo. Je vynucováno pravidlo, že vlákno nemůže zapisovat do bloků, které mají \textit{session id} jiné než takové, které má vlákno právě přiřazeno. Pro každý výpočet hodnoty statické proměnné a pro každý \nonctime rámec (tedy rámce \nonctime funkcí a větvících příkazů) je vláknu přiřazeno unikátní \textit{session id}; říkáme, že vlákno je v dané \textit{session}. Každé \textit{session id} jde přiřadit pouze jednou; jakmile vlákno \textit{session} opustí, není již jakkoli možné editovat paměť, která byla během \textit{session} vytvořena. Během jedné otevřené \textit{session} je ale možné otevřít v témže vlákně jinou; jakmile se tato nová \textit{subsession} ukončí, obnoví se opět ta původní.

Důsledkem těchto pravidel je, že pokus o zápis do statické proměnné nebo proměnné z~jiného rámce (které mají přiřazené jiné \textit{session id}) způsobí chybu, což efektivně zajišťuje dodržení pravidel konceptu líhnutí kódu během kompilace. Dodržování pravidel bude v~budoucnu doplněno ještě mechanismem konstantnosti, který ale v rámci této práce nebyl z~časových důvodů implementován.

V některých případech je žádoucí (například u argumentů volání funkcí, u kterých je třeba odvozovat typ, viz \autoref{sec:overloadResolution}), aby tato ochrana fungovala jednosměrně -- aby z jedné \textit{session} šlo upravovat data jiné, ale ne naopak (v našem příkladě aby se při vyhodnocování argumentu nedalo měnit ostatní data, ale aby po vyhodnocení šlo pracovat s proměnnými, které se vytvořily). Tento problém řeší \textit{subsessions}. Princip je podobný \textit{sessions} -- kromě \textit{session id} je ke každému bloku paměti a každému vlákno přiřazeno \textit{subsession id} (které je vázáno na \textit{session id}). Rozdíl je v tom, že ze \textit{subsession}, která byla vytvořena dříve (=má nižší \textit{subsession id}; a tím pádem musí být buď nadřazená aktuální \textit{subsession}, nebo je již ukončená a tedy z ní již nelze nic měnit), lze upravovat data \textit{subsessions} stejné \textit{session}, které byly vytvořeny později (a tedy mají vyšší \textit{subsession id}).

\putImage[Demonstrace ochrany paměti a dodržování pravidel konceptu líhnutí kódu pomocí \textit{sesisons} a~\textit{subsessions}. Šipky zobrazují přístup k paměti -- plnou čárou zápis, přerušovanou čtení. Červená čára znázorňuje chybu. Čísla v kulatých závorkách u \textit{session id} udávají \textit{subsession id}.]{memorySessions.pdf}{width=14cm}

Z důvodu uspoření paměti probíhá po ukončení každé \textit{session} (po zpracování kódu, který využívá dané \textit{session id}) \textit{garbage collection}, kdy je uvolněna ta paměť, která byla alokovaná v dané \textit{session} a která není nikde ve vygenerovaném kódu (ani nepřímo přes ukazatele) referencovaná. Další \textit{garbage collection} pak probíhá těsně před sestavením výstupního kódu. Při ukončení \textit{subsession} \textit{garbage collection} neprobíhá.

\section{Sémantický strom, interpretace a \textit{backends}} \label{impl:backends}
Důsledkem návrhu jazyka a toho, že je povoleno přetěžování funkcí, je, že nelze generovat cílový kód bez alespoň částečného sestavení sémantického stromu (nebo by se musel generovat kód samostatně pro každé přetížení, poté vybrat jeden a zbytek zahodit). Pro výrazy tedy kompilátor sestavuje sémantický strom; příkazy, cykly, apod. jsou generovány "přímo". Všechny uzly stromu se zakládají na abstraktní třídě \inlineCode{DataEntity}. Nejdůležitější vlastností uzlu je datový typ, jehož hodnotu uzel zastupuje; dále je klíčová virtuální funkce \inlineCode{buildCode} (jejíž implementace se různí podle povahy uzlu), která zajistí sestavení kódu, který odpovídá vyhodnocení daného uzlu, pro daný \textit{backend}.

Kompilátor obsahuje tři \textit{backends}:
\begin{enumerate}
	\item \textbf{Cpp} obstarává sestavení výstupního kódu v jazyce C/C++
	\item \textbf{Ctime} místo sestavení přímo vykonává poskytnutý kód; tento se využívá při vyhodnocování výrazů dekorovaných \inlineCode{@ctime}. Jedná se o interpret prvního stupně (viz \autoref{ctime:orderInterpreters}).
	\item \textbf{Interpret} sestavuje mezikód, který je poté vykonáván při běhu kompilátoru. Mezikód je sestavován pro \nonctime funkce (tedy pro funkce, které se mohou alespoň částečně vykonávat za běhu), které mají být vykonány během kompilace. Jedná se o interpret druhého stupně (viz \autoref{ctime:orderInterpreters}).
\end{enumerate}

Ke všem třem \textit{backends} se přistupuje přes stejné rozhraní, které je založeno na jednoduchých operacích typu "sečti dvě 32bitové ordinální proměnné a výsledek ulož do této proměnné" nebo "sestav \textit{if} konstrukci".

\putImage[Diagram popisující zpracování vstupního kódu v kompilátoru Dragon]{compiling_interpretation.pdf}{width=14cm}

\subsection{Overload resolution} \label{sec:overloadResolution}
Za normálních okolností a bez odvozování typů by při \textit{overload resolution} stačilo sestavit sémantický strom pro každý argument (tím by se zjistil typ každého argumentu) a potom najít nejvhodnější přetížení, případně přidat do sémantického stromu přetypování některých parametrů (implicitní), a tyto uzly sémantického stromu mu předat. První komplikací, jež v Beastu znemožňuje použití tohoto modelu, je to, že typ argumentu může záviset na typu parametru přetížení (tedy sémantický strom může být ve skutečnosti pro každé přetížení jiný) -- toto nastává například při použití konstrukce \inlineCode{:ident} (viz \autoref{colonIdent}), která vyhledává identifikátor \inlineCode{ident} ve jmenném prostoru očekávaného typu parametru, místo aktuálního jmenného prostoru.

Toto je v Dragonu řešeno tak, že pokud je to možné -- pokud daný argument nevyužívá konstrukcí, které odvozují z očekávaného typu parametru -- pak se sestaví sémantický strom pro daný argument pouze jednou; pokud je potřeba odvození, sémantický strom se pro daný argument sestavuje pro každé přetížení.

\putImage[Demonstrace implementace \textit{overload resolution} v kompilátoru Dragon]{overloadResolution.pdf}{width=14cm}

Koncept líhnutí kódu problém ještě komplikuje; existují totiž případy, kdy je kus kódu třeba vykonat již během sestavování sémantického stromu (\textit{overload resolution} také pouze sestavuje uzel sémantického stromu, který odpovídá volání funkce).

\begin{code}[\label{code:overloadResolution:1}]
	Void foo( Int x, Int y ) { ... }
	
	Void main() {
		Int a = 4;
		foo( x++, x );$\label{codeLine:overloadResolution:1}$
	}
\end{code}

Ve výše uvedeném kódu by kompilátor při zpracovávání řádku \ref{codeLine:overloadResolution:1} vytvořil následující sémantický strom:

\putImage[Sémantický strom sestavený na základě volání funkce v příkladu \ref{code:overloadResolution:1} na řádku \ref{codeLine:overloadResolution:1}]{semTreeFuncCall.pdf}{width=14cm}

Uvažme ale následující kód: \nopagebreak

\begin{code}
Void foo( Int x, 5 ) { ... }

Void main() {
	@ctime {
		Int a = 4;
		foo( a, a++ );$\label{codeLine:overloadResolution:2}$
	}
}
\end{code}

Zde je při volání funkce \inlineCode{foo} na řádku \ref{codeLine:overloadResolution:2} potřeba zjistit hodnotu argůmentu již během \textit{overload resolution} (tedy během sestavování sémantického stromu). Pokud bychom vyhodnotili argument 2 (výraz \inlineCode{a++}) při sestavování sémantického stromu, potom by hodnota předaná argumentem 1, který by byl vyhodnocen až později, byla špatná (5 místo očekávaných 4).

Vyhodnocování argumentů již během sestavování sémantického stromu je třeba i v jiných případech -- například u \ctime funkcí, u kterých může být návratový typ v některých případech zjištěn až vykonáním dané funkce.

Vzorový kompilátor Dragon tento problém z časových důvodů neřeší zcela. Momentálně je problém řešen tak, že sestavování sémantického stromu argumentů je uzavřeno do \textit{subsession}, tím pádem během něj nelze měnit hodnoty okolních \ctime proměnných. Toto řešení ale nepokrývá celý problém, vezměme například tento kód:

\begin{code}
Void foo( Int x, 5 ) { ... }

Void main() {
	@ctime {
		Int a = 5;
		foo( a++, a );$\label{codeLine:overloadResolution:3}$
	}
}
\end{code}

Zde je problém demonstrován z druhé strany. Pro posouzení, jestli lze funkci \inlineCode{foo} použít, je třeba během sestavování sémantického stromu vyhodnotit na řádku \ref{codeLine:overloadResolution:3} výraz \inlineCode{a}, který odpovídá druhému argumentu. Ten se vyhodnotí jako 5, což je špatně, protože v předchozím argumentu proměnnou \inlineCode{a} přičítáme (na hodnotu 6). Toto přičtení se ale vykoná až při "sestavování" kódu \textit{Ctime backendem} (který kód okamžitě vykonává; viz \autoref{impl:backends}).

Pro odstranění tohoto problému by bylo potřeba vykonávat kód ihned, tj. nestavět sémantický strom (nebo stavět, ale vykonat ihned po sestavení pro každý argument). Aby se příliš nezvýšila doba kompilace (vzniklá tím, že se pro každé přetížení okamžitě generuje výstupní kód), bylo by vhodné toto provádět pouze při vykonávání \ctime kódu. Tím pádem by se během vykonávání \nonctime kódu zakázalo měnit hodnoty \ctime proměnných. Mít oddělené řádky, kde se mění hodnoty \ctime proměnných a kde se pracuje s \nonctime proměnnými ale není příliš velké omezení, snad by se to dalo nazvat i~dobrou programovací praktikou.

Dalším omezením je nutnost zamezení změny hodnot lokálních proměnných v těch argumentech, kde se využívá odvozování z očekávaného typu parametru, protože tyto argumenty jsou sestavovány (a v případě \ctime kódu i vykonávány) pro každé přetížení. Toto je realizováno pomocí \textit{subsessions} (viz \ref{sec:sessions}). Omezení by se dalo odstranit pouze zavedením možnosti ukládat a navracet se do různých stavů paměti interpretu; poté by se při \textit{overload resolution} postupně vyzkoušela všechny přetížení, po každém přetížení by se navrátil původní stav paměti, a po rozhodnutí správného přetížení by se obnovil stav paměti po zavolání daného přetížení. Je otázkou, zda zrušení relativně malého omezení vyváží zvýšení výpočetních a paměťových nároků, které by přecházení mezi stavy přineslo.

\section{Zrcadlení \ctime proměnných a \ctime zásobník} \label{impl:ctimemirror}
Aby mohly být \ctime proměnné referencovány v \nonctime kódu, musí mít (alespoň ty, které skutečně jsou referencovány) přiřazenou paměť i za běhu aplikace. Data v této paměti musí odpovídat hodnotě dané \ctime proměnné. Pokud si lokální \ctime proměnná dynamicky naalokovala paměť (například uzly u binárního stromu) a pokud je na paměť z lokální proměnné odkazováno, musí být i ona zrcadlena za běhu aplikace. Toto téma je rozvedeno v oddílu \ref{ctime:impl:ref}.

U lokálních \ctime proměnných lze mít paměť pro jejich zrcadlení za běhu uloženou na zásobníku. Protože životnost dynamicky alokovaných \ctime bloků nemusí nutně korespondovat s životností lokálních proměnných (mohou být dealokovány dříve nebo i až po ukončení aktuálního rámce), paměť pro dynamicky alokované \ctime bloky je vhodné dynamicky alokovat i za běhu aplikace. Ukazatel na tuto paměť by měl být uložen buď přímo ve výchozí \ctime lokální proměnné nebo v jiném paměťovém bloku, ke kterému se dá přistoupit přes reference z výchozí lokální proměnné; pokud to takto není, k danému paměťovému bloku se nedá nijak dostat a nemá smysl ho zrcadlit.

Takovýto řetězec referencí, který je potřeba projít, abychom se dostali k nějakému bloku, ale může být potenciálně nekonečně dlouhý. Kompilátor musí mít pro případ, že by se data v~tomto \ctime bloku paměti změnila, nějakým způsobem uložen odkaz na paměť reflektující ho při běhu aplikace, aby tam mohl tuto změnu zrcadlit. Kvůli rychlosti je ale nevhodné, aby měl ale kompilátor při zrcadlení procházet tento potenciálně nekonečný řetězec referencí. Proto se ukazatel na každý blok uchovává ve speciální struktuře částečně zásobníkové povahy (klasický zásobník nejde dost jednoduše použít kvůli výše zmiňovaném rozdílu mezi dobou života lokální proměnné a dynamicky alokované \ctime paměti), která je nazývána \ctime zásobníkem. Takto se subsystém pro zrcadlení \ctime dat může dostat k libovolnému bloku pomocí jediné indirekce.

\putImage[Demonstrace uchovávání referencí na dynamicky alokované \ctime bloky pomocí dedikované struktury]{ctstack.pdf}{width=9cm}

\section{Destruktory \ctime proměnných} \label{impl:destructors}
Koncept líhnutí kódu je navržen tak, aby \ctime proměnné šlo vyhodnocovat již za doby kompilace a aby se toto vyhodnocování nemuselo během kompilace opakovat; v tomto se implementace konceptu podobá preprocesoru (ačkoli koncept líhnutí kódu nelze realizovat pouhým preprocesorem, musí být vestavěn do samého jádra jazyka). Během vývoje kompilátoru byl ale nalezen jeden případ, kde toto neplatí. Uvažujeme-li, že lokální \ctime proměnné se chovají úplně stejně jako normální lokální proměnné, musí při opuštění rámce být vykonán jejich destruktor; pořadí vykonávání destruktorů je určeno jako opačné pořadí, v jakém byly lokální proměnné definovány (nezávisle na tom, zda jsou \ctime, či nikoli).

Nyní uvažme, co by se mělo stát, když má být v dané funkci vykonán příkaz \inlineCode{return}. Příkaz \inlineCode{return} způsobuje zavolání destruktorů všech "aktuálně definovaných" lokálních proměnných ve všech rámcích až po kořenový rámec funkce. Tím pádem by měly být vykonány i destruktory lokálních \ctime proměnných. Nicméně jak je uvedeno výše, v tomto ohledu je \ctime kód zpracováván podobně jako preprocesorem, takže pokud by se u příkazu \inlineCode{return} vykonaly destruktory \ctime proměnných, tyto destruktory by se jakoby vykonaly i v případě, kdy by samotný příkaz \inlineCode{return} vykonán nebyl (například kvůli nesplněné podmínce). Obdobně tomu je i u příkazů \inlineCode{break} a \inlineCode{continue}.

Demonstrační kompilátor tento problém aktuálně "řeší" tak, že destruktory lokálních \ctime proměnných nejsou na koncích rámců volány vůbec. Jediným doposud nalezeným řešením tohoto problému je implementace možnosti navrácení se do předchozích uložených stavu \ctime paměti v kompilátoru. V takovém případě by se při zpracovávání příkazu \inlineCode{return} uložil aktuální stav paměti, pak by se zavolaly destruktory (\nonctime i \ctime proměnných; \ctime proměnné by byly korektně zrcadleny) a do výstupního kódu by se přidal samotný kód pro ukončení funkce. Poté by se paměť \ctime proměnných uložená v~kompilátoru navrátila zpět do stavu, než byly zavolány destruktory.

\section{Konfigurace projektu}
Kompilátor Dragon umožňuje konfiguraci Beast projektu pomocí souboru \inlineCode{beast.json}, který je v textovém formátu JSON, který bývá uložen v kořenovém adresáři projektu. V tomto souboru je možné nakonfigurovat například cesty ke složkám, ve kterých má kompilátor hledat zdrojové soubory, výstupní složku a název výstupního souboru, použitý C kompilátor a kompilovací příkaz, formát chybových hlášek, apod. Všechny položky konfigurace je také možné nastavit pomocí argumentů v příkazové řádce.

Kompilátor momentálně podporuje dva formáty výstupu chybových hlášek -- buď ve standardním formátu GNU \cite{GNUErrors}, který je cílen na čitelnost pro uživatele, nebo ve formátu JSON, který má být lehce strojove zpracovatelný a usnadnit tak integraci vývojových prostředí.

\section{Rozbor kódu generovaného kompilátorem}
V této sekci se podíváme na příklad zdrojového kódu v jazyce Beast a na transkompilovaný kód v jazyce C, který kompilátor Dragon pro daný příklad generuje. Bude předveden jednoduchý příklad, který ale pokrývá všechny klíčové aspekty, které je vhodné demonstrovat.

Příklad je následující: \nopagebreak

\begin{code}[\label{impl:gencode:sample}]
module t_bachelorgenexample;

@ctime Int? valPtr := val;
@ctime Int val = 3 + 5;

Void foo( Int x ) {
	print( x );
}

Void main() {
	@ctime Int! x = 5;
	@ctime Int! y = 6;
	foo( @ctime x + y ); //! stdout: 11
	
	@ctime Int!? ref := x;
	foo( ref ); //! stdout: 5
	
	@ctime ref := y;
	foo( ref ); //! stdout: 6
	
	foo( valPtr ); //! stdout: 8
}
\end{code}

Výstupní C kód je dlouhý, a proto je rozdělen na menší části, které jsou popsány postupně:

\begin{cppcode}[Část 1 z C kódu generovaného překladačem Dragon ze zdrojového kódu \ref{impl:gencode:sample}]
#define VAL( var, type ) ( *( ( type* )( var ) ) )
#define TYPEDEF( id, size ) typedef struct { uintptr_t data[ size ]; } id
#define PARAM( expr, type ) ( ( type* )( expr ) )
#define DEREF( expr ) ( *( ( uintptr_t ** )( expr ) ) )
#define OFFSET( expr, offset ) ( ( uintptr_t* ) ( ( ( uint8_t* ) expr ) + offset ) )
#define CTMEM

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

uintptr_t *ctimeStack[ 1024 * 1024 ];
size_t ctimeStackSize = 0;
\end{cppcode}

Tato část neobsahuje moc zajímavého, a proto ji přeskočíme.

\begin{cppcode}[Část 2 z C kódu generovaného překladačem Dragon ze zdrojového kódu \ref{impl:gencode:sample}]
// TYPES
TYPEDEF( _spscmp2_Type, 1 );
TYPEDEF( _fbwm2d_Pointer, 1 );
TYPEDEF( _bug1ph_Int32, 1 );
TYPEDEF( _irqo202_Int64, 2 );
typedef void _4fdej5_Void;
TYPEDEF( _wpmdt21_Bool, 1 );
TYPEDEF( _86g1r42_Operator, 1 );
TYPEDEF( _vkbk102__Ctor, 1 );
TYPEDEF( _5bpj6k_Null, 1 );
TYPEDEF( _gaucg12_Void_ref, 1 );
TYPEDEF( _kmadlv3_Type_ref, 1 );
TYPEDEF( _ei66v8_Pointer_ref, 1 );
TYPEDEF( _1fpv2r1_Int32_ref, 1 );
TYPEDEF( _a6wkqe_Int64_ref, 1 );
TYPEDEF( _tj3tms3_Bool_ref, 1 );
TYPEDEF( _stbv9i2_Operator_ref, 1 );
TYPEDEF( _fr2o741__Ctor_ref, 1 );
TYPEDEF( _41phrv1_Null_ref, 1 );
\end{cppcode}

Výše uvedená sekce zrcadlí datové typy z Beast kódu. Lze vidět, že transkompilátor třídy nezrcadlí naivně strukturami v C, ale s typy pracuje "surově"; datový typ je v~C~zrcadlen jen jako kus paměti o~určitém počtu bytů. Počet bytů typu se zaokrouhluje nahoru na násobek velikosti ukazatele.

\begin{cppcode}[Část 3 z C kódu generovaného překladačem Dragon ze zdrojového kódu \ref{impl:gencode:sample}]
// MEMORY BLOCKS DECLARATIONS
extern uintptr_t _0xc0_valPtr[1];
extern uintptr_t _0xc4_val[1];

// MEMORY BLOCKS
uintptr_t _0xc0_valPtr[1] = { (uintptr_t) CTMEM &_0xc4_val };$\label{impl:gencode:output:valPtrDef}$
uintptr_t _0xc4_val[1] = { 0x8 };
\end{cppcode}

Tato sekce zrcadlí statické proměnné, a to jak klasické, tak \ctime (ale pouze pokud jsou použity v kódu). Zrcadlení je provedeno ve dvou fázích -- deklarace a definice -- aby se nemuselo řešit pořadí definic kvůli ukazatelům v datech. Data jsou ukládána jako pole položek typu \inlineCppCode{uintptr_t}, aby šlo do literálů polí (které jsou používány pro inicializaci statických proměnných) vkládat ukazatele, jak je demonstrováno na řádku \ref{impl:gencode:output:valPtrDef}.

Názvy funkcí, typů a proměnných obsahují \textit{hash}, který má napomoci jejich identifikaci (mimo jiné je to třeba kvůli přetěžování).

\begin{cppcode}[Část 4 z C kódu generovaného překladačem Dragon ze zdrojového kódu \ref{impl:gencode:sample}]
// DECLARATIONS
void _tfhj4t2_foo( _bug1ph_Int32 *_p0_x );
void _69b6o33_main( );

//DEFINITIONS
void _tfhj4t2_foo( _bug1ph_Int32 *_p0_x ) {
	size_t ctimeStackBP = ctimeStackSize;
	{
		/* print( x ) */
		{
			printf( "%i", VAL( _p0_x, int32_t ) );
		}
	}
	return;
	fprintf( stderr, "ERROR: Function test.foo( core.Int32 x ) did not exit via return statement\n" );
	exit( -1 );
}
\end{cppcode}

Poslední sekcí je sekce pro funkce, opět napřed deklarace a pak definice. Ačkoli jsou v Beastu data předávána hodnotou, v transkompilovaném C kódu se parametry funkcí předávají odkazem, aby měl Beast kontrolu nad voláním konstruktorů a destruktorů a~nad tím, kde v paměti se data argumentů nachází. Do budoucna je plán předávat primitivní typy a typy z nich odvozené (u kterých je kopírovací konstruktor realizován pouhým zkopírováním paměti) hodnotou.

Nyní se podíváme na implementaci funkce \inlineCode{main}. Tato funkce není přímo zrcadlena na \inlineCppCode{main} v jazyce C kvůli předávaným parametrům a kvůli případným konstruktorům statických proměnných, které jsou v jazyce C volány právě ve funkci \inlineCppCode{main}.

\begin{cppcode}[Část 5 z C kódu generovaného překladačem Dragon ze zdrojového kódu \ref{impl:gencode:sample}]
void _69b6o33_main( ) {
	size_t ctimeStackBP = ctimeStackSize;
	{
		/* @ctime Int! x = 5; */$\label{impl:gencode:sample:2}$
		/* @ctime Int! y = 6; */$\label{impl:gencode:sample:3}$
		/* foo( @ctime x + y ) */
		{
			_bug1ph_Int32 _7la7b83_tmp;
			// alloc 0xdc x
			ctimeStack[ ctimeStackBP + 0 ] = (uintptr_t*) malloc( 4 );
			// alloc 0xec y
			ctimeStack[ ctimeStackBP + 1 ] = (uintptr_t*) malloc( 4 );
			{
				// update 0xdc x
				static uint8_t _ctData[ 4 ] = { 0x5, 0, 0, 0 };
				memcpy( ctimeStack[ ctimeStackBP + 0 ], _ctData, 4 );
			}
			{
				// update 0xec y
				static uint8_t _ctData[ 4 ] = { 0x6, 0, 0, 0 };
				memcpy( ctimeStack[ ctimeStackBP + 1 ], _ctData, 4 );
			}
			// alloc 0xf4 tmp
			ctimeStack[ ctimeStackBP + 2 ] = (uintptr_t*) malloc( 4 );
			{
				// update 0xf4 tmp
				static uint8_t _ctData[ 4 ] = { 0xb, 0, 0, 0 };
				memcpy( ctimeStack[ ctimeStackBP + 2 ], _ctData, 4 );
			}
			VAL( &_7la7b83_tmp, uint32_t ) = VAL( CTMEM ctimeStack[ ctimeStackBP + 2 ], uint32_t );
			ctimeStackSize = ctimeStackBP + 3;
			_tfhj4t2_foo( PARAM( &_7la7b83_tmp, _bug1ph_Int32 ) );
			// &_7la7b83_tmp DTOR
			// free 0xf4 tmp
			free( ctimeStack[ ctimeStackBP + 2 ] );
		}
\end{cppcode}

Všimněme si, že první dva příkazy (řádky \ref{impl:gencode:sample:2} a \ref{impl:gencode:sample:3}), které jsou \ctime, nemají žádný odpovídající kód ve výstupním kódu. Veškeré zrcadlení proměnných (viz \autoref{ctime:ref} a \autoref{impl:ctimemirror}) probíhá až před vykonáním \nonctime výrazu. Ačkoli v oddílu \ref{impl:ctimemirror} bylo řečeno, že by data lokálních \ctime proměnných bylo vhodné ukládat na zásobník, všechny \ctime proměnné a data jsou z~časových důvodů uloženy na \ctime zásobník, taktéž popsaný v~podkapitole \ref{impl:ctimemirror}.

Zrcadlení \ctime proměnné tedy spočívá v alokaci paměti pro tuto proměnnou (pokud již nebyla alokována dříve) a ve vložení dat do této paměti (zde realizováno pomocí \inlineCppCode{memcpy}). V systému momentálně není implementovaná detekce toho, zda je proměnná referencována, či nikoli -- jsou tedy zrcadleny všechny \ctime proměnné.

Funkce \inlineCode{main} dále pokračuje:

\begin{cppcode}[Část 6 z C kódu generovaného překladačem Dragon ze zdrojového kódu \ref{impl:gencode:sample}]
		/* @ctime Int!? ref := x; */
		/* foo( ref ) */
		{
			_bug1ph_Int32 _499a3c1_tmp;
			// alloc 0xf0 ref
			ctimeStack[ ctimeStackBP + 3 ] = (uintptr_t*) malloc( 4 );
			{
				// update 0xf0 ref
				static uint8_t _ctData[ 4 ] = { 0xdc, 0, 0, 0 };
				memcpy( ctimeStack[ ctimeStackBP + 3 ], _ctData, 4 );
				VAL( CTMEM ctimeStack[ ctimeStackBP + 3 ], void* ) = CTMEM ctimeStack[ ctimeStackBP + 0 ];$\label{impl:gencode:sample:1}$
			}
			VAL( &_499a3c1_tmp, uint32_t ) = VAL( CTMEM DEREF( CTMEM ctimeStack[ ctimeStackBP + 3 ] ), uint32_t );
			ctimeStackSize = ctimeStackBP + 4;
			_tfhj4t2_foo( PARAM( &_499a3c1_tmp, _bug1ph_Int32 ) );
			// &_499a3c1_tmp DTOR
		}
\end{cppcode}

Zde je práce s \ctime proměnnou ozvláštněna o to, že se jedná o referenci. Kompilátor si uchovává přehled o tom, která místa v paměti (interpretu) jsou použita jako reference, mapováním volání konstruktorů/destruktorů referenčních typů. Protože paměťový prostor výsledné aplikace se neshoduje s paměťovým prostorem interpretu (kompilátoru), je třeba reference "překládat" (viz \autoref{ctime:impl:ref} a \autoref{impl:ctimemirror}). Protože jsou (nestatické) \ctime proměnné alokovány dynamicky, mapování \ctime adres na \nonctime adresy není během kompilace znám. Je třeba vytvořit kód, který mapování provede za běhu; tomu odpovídá řádek \ref{impl:gencode:sample:1}.

Zrcadlení \ctime proměnné tedy probíhá ve třech fázích: alokace, vložení dat a vložení referencí.

Zbytek kódu už nepřináší nic nového a tedy není třeba jej komentovat:

\begin{cppcode}[Část 7 z C kódu generovaného překladačem Dragon ze zdrojového kódu \ref{impl:gencode:sample}]
		/* @ctime ref := y */
		/* foo( ref ) */
		{
			_bug1ph_Int32 _dm8gj4_tmp;
			{
				// update 0xf0 ref
				static uint8_t _ctData[ 4 ] = { 0xec, 0, 0, 0 };
				memcpy( ctimeStack[ ctimeStackBP + 3 ], _ctData, 4 );
				VAL( CTMEM ctimeStack[ ctimeStackBP + 3 ], void* ) = CTMEM ctimeStack[ ctimeStackBP + 1 ];
			}
			VAL( &_dm8gj4_tmp, uint32_t ) = VAL( CTMEM DEREF( CTMEM ctimeStack[ ctimeStackBP + 3 ] ), uint32_t );
			ctimeStackSize = ctimeStackBP + 4;
			_tfhj4t2_foo( PARAM( &_dm8gj4_tmp, _bug1ph_Int32 ) );
			// &_dm8gj4_tmp DTOR
		}
		/* foo( valPtr ) */
		{
			_bug1ph_Int32 _shscpv_tmp;
			VAL( &_shscpv_tmp, uint32_t ) = VAL( CTMEM DEREF( CTMEM &_0xc0_valPtr ), uint32_t );
			ctimeStackSize = ctimeStackBP + 4;
			_tfhj4t2_foo( PARAM( &_shscpv_tmp, _bug1ph_Int32 ) );
			// &_shscpv_tmp DTOR
		}
	}
	// free 0xec y
	free( ctimeStack[ ctimeStackBP + 1 ] );
	// free 0xdc x
	free( ctimeStack[ ctimeStackBP + 0 ] );
	// free 0xf0 ref
	free( ctimeStack[ ctimeStackBP + 3 ] );
	return;
	fprintf( stderr, "ERROR: Function test.main(  ) did not exit via return statement\n" );
	exit( -1 );
}

int main() {
	size_t ctimeStackBP = ctimeStackSize;
	if( sizeof( void* ) != 4 ) {
		fprintf( stderr, "Beast compiler considered pointer size 4 but C compiler used %s", sizeof(void*) );
		exit( -1 );
	}
	ctimeStackSize = ctimeStackBP + 0;
	_69b6o33_main(  );
	return 0;
}
\end{cppcode}

\section{Implementované a neimplementované prvky}

Časová dotace na implementaci demonstračního kompilátoru byla soustředěna zejména na koncept líhnutí kódu, na mnoho prvků jazyka nezbyl čas. V této sekci naleznete přehled toho, co v rámci bakalářské práce bylo v kompilátoru implementováno a co ne.

\begin{center}
	\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
		\multicolumn{2}{c}{\bfseries \large Koncept líhnutí kódu} \\
		\hline \\
		Implementováno & Neimplementováno \\
		\begin{compactitem}
				\item Statické, lokální a dynamicky alokované \ctime proměnné
				\item Zrcadlení \ctime proměnných za doby běhu, včetně referencí
				\item Statické funkce s \ctime parametry
				\item Vykonávání funkcí za doby kompilace
				\item Typové proměnné
				\item Parametry s konstantní hodnotou
		\end{compactitem} &
		\begin{compactitem}
				\item Generické třídy
				\item Členské funkce (nestatické třídní) s~\ctime parametry
				\item \ctime cykly
				\item \ctime funkce a třídy
				\item Reflexe
				\item Volání destruktorů \ctime proměnných
				\item Opravení jisté chyby při vykonávání \ctime kódu, viz \autoref{impl:destructors}
		\end{compactitem} \\
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
		\multicolumn{2}{c}{\bfseries \large Třídy, výčty, typy} \\
		\hline \\
		Implementováno & Neimplementováno \\
		\begin{compactitem}
			\item Uživatelem definované třídy
			\item Kompilátorem definované výčty
			\item Typy \inlineCode{Int32}, \inlineCode{Int64}, \inlineCode{Bool} a základní operátory a operace pro ně (\inlineCode{+}, \inlineCode{\-}, \inlineCode{*}, \inlineCode{/}, \inlineCode{!}, \inlineCode{&&}, \inlineCode{||})
			\item Referenční typy, typ \inlineCode{Pointer}
			\item Přetěžování operátorů
		\end{compactitem} &
		\begin{compactitem}
			\item Generické třídy
			\item \ctime třídy
			\item Uživatelem definované výčty
			\item Automatické generování konstruktorů
			\item Model dědičnosti, virtuální funkce, ...
			\item Další typy -- řetězce, pole, ...
		\end{compactitem} \\
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
		\multicolumn{2}{c}{\bfseries \large Funkce} \\
		\hline \\
		Implementováno & Neimplementováno \\
		\begin{compactitem}
			\item Statické i třídní funkce
			\item \inlineCode{auto} návratové typy, typy parametrů i definice proměnných
			\item \ctime proměnné jako parametry statických funkcí
			\item Funkce \inlineCode{print} a \inlineCode{assert}
			\item Funkce \inlineCode{malloc} a \inlineCode{free}
			\item Parametry s konstantní hodnotou
			\item \textit{Overload resolution} (vhodné ještě vylepšit)
			\item Funkce \inlineCode{to} pro explicitní přetypování
		\end{compactitem} &
		\begin{compactitem}
			\item \ctime proměnné jako parametry třídních funkcí
			\item \ctime funkce
			\item \inlineCode{realloc}
			\item Instance "šablonových" funkcí (funkcí s \ctime parametry) se nesjednocují, ani když mají stejné hodnoty argumentů
			\item Funkce nejsou \textit{first-class citizens} (nelze mít uložen ukazatel na funkci)
		\end{compactitem} \\
	\end{tabular}
\end{center}
\begin{center}
	\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
		\multicolumn{2}{c}{\bfseries \large Kompilátor, syntaxe} \\
		\hline \\
		Implementováno & Neimplementováno \\
		\begin{compactitem}
			\item Detekce cyklických závislostí
			\item Vícevláknový kompilátor
			\item \inlineCode{:ident} konstrukce
			\item \inlineCode{if}, \inlineCode{while} větvící příkazy
			\item \inlineCode{new}, \inlineCode{delete} příkazy
			\item Základy modularity
			\item Konfigurační soubor projektu
			\item Dekorátory \inlineCode{@ctime} a \inlineCode{@static}
			\item Implicitní a explicitní přetypování
		\end{compactitem} &
		\begin{compactitem}
			\item Konstantnost všeobecně, const-by-default
			\item \inlineCode{import} pro komunikaci mezi moduly
			\item Uživatelem definované dekorátory
			\item Omezení přístupu -- \inlineCode{@public}, \inlineCode{@private}, ...
			\item Další důležité dekorátory
			\item Další operátory jako \inlineCode{|}, \inlineCode{+=}, \inlineCode{++}, atp.
			\item Systém výjimek
			\item Další cykly, jako \inlineCode{for}, \inlineCode{do .. while}, atp.
			\item Konstrukce \inlineCode{while}-\inlineCode{else} (viz \ref{design:whileElse})
			\item Lambda výrazy
			\item Další věci nezmíněné jako implementované
		\end{compactitem} \\
	\end{tabular}
\end{center}

\chapter{Závěr}
Během návrhu jazyka Beast vznikl nový koncept, koncept líhnutí kódu, který inovuje oblast metaprogramování a vykonávání kódu za doby kompilace; tato práce se zabývá zejména tímto konceptem. Byly navrženy základní aspekty jazyka Beast a naznačen další směr jeho vývoje. Byl implementován demonstrační kompilátor Dragon, který se z~časových důvodů soustředil především na demonstraci konceptu líhnutí kódu; vlivem toho nezbyly prostředky na rozvedení ostatních vlastností jazyka. Při vývoji této práce bylo použito verzovacího prostředí git a veškeré podklady (zdrojový kód kompilátoru, bakalářská práce, specifikace jazyka, sada testů) jsou uloženy na githubu\footnote{\url{https://github.com/beast-lang/beast-dragon}} pod MIT licencí.

Autor zamýšlí navázat na tento projekt ve své diplomové práci, kde bude cílem dokončit implementaci nejdůležitějších prvků jazyka do kompilátoru Dragon -- zejména koncept líhnutí kódu, poté například třídní dědičnost, \textit{first-class citizenship} funkcí, dekorátory, apod. Nicméně prostředky nutné k dotažení kompilátoru a jazyka do takové podoby, aby byly komerčně využitelné, značně přesahují časovou dotaci i pro bakalářskou a diplomovou práci dohromady.
