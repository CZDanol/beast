% !TeX spellcheck = en_US

\include{header}
\include{mainpage}
\include{support}

\setlength\extrarowheight{2pt}

% Title Page
\title{Beast programming language}
\subtitle{Language specification/reference}
\author{Daniel 'Danol' ÄŒejchan}
\date{2016-2017}


\begin{document}
\mainpage
%\renewcommand{\clearpage}{}

\chapter{Table of contents}
\makeatletter
\setcounter{tocdepth}{1}
\@starttoc{toc}
\makeatother

\chapter{Introduction}
Beast is an imperative, structured, modular programming language supporting OO and functional paradigms. Currently, only transcompilation to C is available. In future, a LLVM backend integration is planned.

Most notably, the language implements a new concept called \textit{code hatching} (also a subject of this paper) that unifies templating, compile-time function execution, compile-time reflection and metaprogramming in general.

\section{Inspiration}
\paragraph{Inspiration from C++}
\begin{compactitem}
	\item Most of the syntax
\end{compactitem}

\paragraph{Inspiration from D}
\begin{compactitem}
	\item Module system (not implemented yet)
	\item Compile-time function execution
\end{compactitem}

\paragraph{Ideas not directly inspired by other languages}
\begin{compactitem}
	\item Code hatching concept
	\item Language reflection
	\item The \hyperref[colonAccessor]{\kwd{:}} accessor
	\item The \hyperref[constantValueParameter]{constant value function parameters}	
	\item Decorators (not implemented yet)
\end{compactitem}

\chapter{Lexical}
In a normal code, Beast accepts only standard ASCII characters. Non-ascii characters are allowed only in comments.

\begin{grammar}
	\tokenDef{Whitespace} \verb|[\n\t\r ]+|
\end{grammar}

\section{Identifiers}
\begin{grammar}
	\tokenDef{Identifier} \verb|[#a-zA-Z_][a-zA-Z_0-9]*|
\end{grammar}
An identifier consists of any combination of lower and upper case ASCII letters, numbers and undescores, with these additional rules:
\begin{itemize}
	\item An identifier cannot begin with a number.
	\item An identifier can begin with the hasthag (\verb|#|) character. These identifiers are used in various language constructs and can have restrictions of where and how they can be used in declarations.
\end{itemize}

\section{Keywords} \label{keywords}
More keywords will be added in the future.

\begin{code}
auto, break, class, delete, else, if, module, new, return, while
\end{code}

\section{Operators}
\begin{code}
+ - * / ? ! == != > >= < <= && || ! = :=
\end{code}

\section{Special tokens}
\begin{code}
. , @ ( ) { }
\end{code}

\section{Literals}
\begin{grammar}
	\grDef{Literal} \gr{IntLiteral} \\
\end{grammar}

\subsection{Boolean 'literals'}
Beast does provide \inlineCode{true} and \inlineCode{false}, however those are not keywords or literals, but just \decoratorRef{ctime} variables defined from the runtime library. That means that they can be redefined.

\subsection{The 'null' 'literal'}
The \inlineCode{null} is of an unspecified type that is statically implicitly castable to pointer or reference of any type. It is not a keyword; it is defined in runtime library and thus can be redefined.

\subsection{Integer literals}
Integer literal is always of type \inlineCode{Int32}.

\begin{grammar}
	\tokenDef{IntLiteral} \verb|-?[0-9]+| 
\end{grammar}

\section{Comments}
\begin{grammar}
	\tokenDef{LineComment} \verb|//[^\n$][\n$]| \\
	\tokenDef{Comment} \verb|/\*.*?\*/|
\end{grammar}
Additionally, \textbf{comments can be nested}.

\begin{code}
void main() {
	/* This is a comment
		/* This is a comment, too. */
		Still a comment */
	thisIsACode();
}
\end{code}

\chapter{Expressions}
\begin{grammar}
	\grDef{Expression} \gr{AssignExpr} \\		
		\grAltLn \gr{DecoratedExpression} \\
		
	\grDef{ParentCommaExpr} \kwd{(} [ \gr{Expression} \{ \kwd{,} \gr{Expression} \} ] \kwd{)} \\
	
	\grDef{DecoratedExpression} \{ \gr{Decoration} \}+ \gr{AssignExpr} \\
\end{grammar}

\section{Operators}
\begin{grammar}	
	\grDef{AssignExpr} \gr{LogicExpr} \\
		\grAltLn \gr{LogicExpr} \kwd{=} \gr{LogicExpr} \\
		\grAltLn \gr{LogicExpr} \kwd{:=} \gr{LogicExpr} \\
	
	\grDef{LogicExpr} \gr{CmpExpr} \\
		\grAltLn \gr{CmpExpr} \{ \kwd{\&\&} \gr{CmpExpr} \}+ \\
		\grAltLn \gr{CmpExpr} \{ \kwd{||} \gr{CmpExpr} \}+ \\
		
	\grDef{CmpExpr} \gr{SumExpr} \\
		\grAltLn \gr{SumExpr} \kwd{!=} \gr{SumExpr} \\
		\grAltLn \gr{SumExpr} \{ ( \kwd{==} | \kwd{>=} | \kwd{>} ) \gr{SumExpr} \}+ \\
		\grAltLn \gr{SumExpr} \{ ( \kwd{==} | \kwd{<=} | \kwd{<} ) \gr{SumExpr} \}+ \\
		
	\grDef{SumExpr} \gr{MultExpr} \\
		\grAltLn \gr{MultExpr} \{ ( \kwd{+} | \kwd{-} ) \gr{MultExpr} \}+ \\
	
	\grDef{MultExpr} \gr{VarDeclExpr} \\
		\grAltLn \gr{NewExpr} \{ ( \kwd{*} | \kwd{/} ) \gr{NewExpr} \}+ \\
		
	\grDef{NewExpr} \gr{PrefixExpr} \\
		\grAltLn \kwd{new} \gr{PrefixExpr} [ \gr{ParentCommaExpr} ] \\

	\grDef{PrefixExpr} \gr{SuffixExpr} \\
		\grAltLn \kwd{!} \gr{SuffixExpr} \\
		
	\grDef{SuffixExpr} \gr{AtomExpr} \\
		\grAltLn \kwd{auto} \\
		\grAltLn \gr{AtomExpr} \{ \gr{SuffixOp} \}+ \\
	
	\grDef{AtomExpr} [ \kwd{:} ] \token{Identifier} \\
		\grAltLn \gr{Literal} \\
		\grAltLn \gr{Identifier} \\
		\grAltLn \gr{ParentCommaExpr} \\
	
	\grDef{SuffixOp} \gr{ParentCommaExpr} \\
		\grAltLn \kwd{.} \token{Identifier} \\
		\grAltLn \kwd{?} | \kwd{!} \\
		\grAltLn \gr{ParentCommaExpr}
\end{grammar}

\subsection{Operator precedence} \label{opPrecedence}
\begin{centeredRefTabular}{P{1.5cm} | c | p{6cm} | c}
	\textbf{Priority} & \textbf{Operator} & \textbf{Semantics} & \textbf{Assoc.} \\ \hline \hline
	
	1
		& \inlineCode{x(args)} & Function call & \multirow{7}{*}{L$\rightarrow$R} \\
		& \inlineCode{x.ident} & Member access & \\
		\cline{2-4}
		& \inlineCode{x!} & Mutable type & \\
		& \inlineCode{x?} & Reference type & \\
	\hline
	
	2
		& \inlineCode{!x} & Logical NOT & \multirow{1}{*}{NOCH} \\
	\hline
	
	3
		%& \inlineCode{T id = args} & (not overloadable) & In-expression variable declaration & \multirow{2}{*}{NOCH} \\
		& \inlineCode{new x( args )} & Dynamic construction & NOCH \\
	\hline
	
	4
		& \inlineCode{x * y} & Multiplication & \multirow{2}{*}{L$\rightarrow$R} \\
		& \inlineCode{x / y} & Division \\
	\hline
	
	5
		& \inlineCode{x + y} & Addition & \multirow{2}{*}{L$\rightarrow$R} \\
		& \inlineCode{x - y} & Subtraction & \\
	\hline
	
	6
		& \inlineCode{x != y} & Not equal to & \multirow{1}{*}{NOCH} \\
		\cline{2-4}
		& \inlineCode{x < y} & Less than & \\
		& \inlineCode{x <= y} & Less than or equal to & \multirow{3}{*}{\parbox{1cm}{\centering L$\rightarrow$R\\SPEC}} \\
		& \inlineCode{x == y} & Equal to & \\
		& \inlineCode{x >= y} & Greater than or equal to & \\
		& \inlineCode{x > y} & Less than & \\
	\hline
	
	7
		& \inlineCode{x && y} & Logical AND & \multirow{2}{*}{\parbox{1cm}{\centering L$\rightarrow$R,\\SAME}} \\
		& \inlineCode{x || y} & Logical OR & \\
	\hline
	
	8
		& \inlineCode{x = y} & Assignment & \multirow{2}{*}{\parbox{1cm}{\centering NOCH}} \\
		& \inlineCode{x := y} & Reference assignment & \\
	\hline

\end{centeredRefTabular}

\paragraph{Associativity -- explanation}
\begin{compactitem}
	\item \textbf{L$\rightarrow$R} Operations from the same group are processed from left to right, meaning \inlineCode{x + y + z} is processed as \inlineCode{(x + y) + z}.
	%\item \textbf{R$\rightarrow$L} Operations from the same group are processed from right to left, meaning \inlineCode{x = y = z} is processed as \inlineCode{x = (y = z)}.
	\item \textbf{NOCH} Operations cannot be chained with any operator of the same priority, meaning expressions like \inlineCode{x >> y >> z}, \inlineCode{x >> y << z} or \inlineCode{++!x} are syntactically incorrect.
	\item \textbf{SAME} Only the same operators can be chained, meaning \inlineCode{x & y & z} and \inlineCode{x | y | z} is correct, but \inlineCode{x & y | z} is not.
	\item \textbf{SPEC} Specific chaining rules, described in following sections.
\end{compactitem}

\paragraph{Evaluation order}
Operands are evaluated left to right, if not specified otherwise.

\subsection{Comparison operators chaining} Comparison operators can be chained in monotonous order:

\begin{code}
// (Almost) equivalent with (a > b) && (b >= c) && (c == d) && (d >= e) && (e > f)
a > b >= c == d >= e > f;
// (Almost) equivalent with (a <= b) && (b < c) && (c <= d) && (d == e) && (e < f)
a <= b < c <= d == e < f;
// (Almost) equivalent with (a == b) && (b == c)
a == b == c;
// Syntax error
a > b < c;
\end{code}

When chaining comparison operators, the expressions in form \inlineCode{x == y > z} are internally rewritten to \inlineCode{(x == y) && (x > z)} (supports user overloaded operators), except the \verb|x|, \verb|y| and \verb|z| expressions are evaluated only once.

\section{Overloadsets (symbols, symbol lookup, identifier resolution, overloading)}
Overloadset is a language structure, a container with all symbols that match currently processed expression. Consider following example:

\begin{code}
Void f() {}$\label{codeLine:overloadSets1:fDecl}$

Void main() {
	f();$\label{codeLine:overloadSets1:fCall}$	
}
\end{code}

Here, when processing the function call on line \ref{codeLine:overloadSets1:fCall}, the compiler starts with identifier \inlineCode{f}. It constructs an overloadset which contains the function \inlineCode{f} defined on line \ref{codeLine:overloadSets1:fDecl}. Then, it reads parentheses, so it will look up for operator \inlineCode{x(args)} in the previous overloadset and put everything it has found to a new overloadset. Then, a process which selects the best matching overload is performed (will be described later in this chapter).

Now let's explain that process step by step.

\subsection{Recursive identifier resolution} \label{fullIdentifierResolution}
When there's an expression that starts with an identifier (\gr{AtomExpr}, the \token{Identifier} version), a recursive identifier resolution is performed for it. This is done by searching symbols with the desired identifier in the current scope. If there is no match in the current scope, the compiler looks into parent scope, and so on. As soon as a match is found, the resolution ends, returning an overloadset with all matching symbols in the currently searched scope. If no match is found, an error is shown.

\subsection{Local identifier resolution} \label{scopedIdentifierResolution}
The scoped identifier resolution is similar to the full identifier resolution, except it doesn't look into parent scopes at all.

\subsection{The '\inlineCode{:ident}' accessor} \label{colonAccessor}
This language construct can be used for example in parameter lists. When used, a \textbf{\hyperref[scopedIdentifierResolution]{scoped identifier resolution} is run} instead of the full identifier resolution. Also, \textbf{the resolution is not performed for the current scope but for the scope of an expected data type}. In function calls, the expected data type would be parameter data type. Please mote that operators are also translated into function calls, so this construct works with operators, too.

This of course does not work with \kwd{auto} parameters.

\begin{code}
enum Enum {
	a, b, c, d
}

Void f( Enum e ) {}

Void main() {
	// Following lines are semantically identical
	f( Enum.a );
	f( :a );	
}
\end{code}

\subsection{Overload resolution} \label{overloadResolution}
Overload resolution is performed every time the compiler needs to match arguments to a function overload. The process is performed over an overloadset where all items must be \textit{callables} (meaning they support overload resolution; error is shown otherwise).

Each overload is assigned a "match level" number. Then, the overload with lowest match level is selected; if no overload matches given arguments, an error is shown; if there are more overloads with the same lowest match level, an error is shown. Overload match level is determined as a sum of $2^i$ of the following:

\begin{compactenum}
	\item Implicit cast needed for at least one argument
	\item Inferration needed for at least one anrgument (used \inlineCode{:ident})
	\item Function is static
	\item Function is compiler-defined
	\item General fallback (compiler-defined)
\end{compactenum}

\subsection{Type conversion} \label{typeConversion}
Beast introduces implicit and explicit cast. Implicit cast are used whenever there's mismatch between expected type and the type provided (for example when passing an argument to a function), explicit casting is done using function \inlineCode{to( @ctime Type targetType )} (which also tries implicit casting if there is no explicit cast available).

Implicit casting is realized by calling \inlineCode{var.#implicitCast( TargetType )}, where \inlineCode{TargetType} being the type the cast is intended to. The function has to return value of \inlineCode{TargetType}. Explicit cast is realized by calling \inlineCode{var.#explicitCast( TargetType )} in the same manner.

\section{Operator overloading} \label{operatorOverloading}
Generally, all operators can be overloaded. Most operators are assigned an item in the \inlineCode{Operator} enum. Operator overloading rules are described in the table below; the "Enum" column corresponds with names of the \inlineCode{Operator} enum items (and the \inlineCode{@ctime Operator op} argument in the "Resolution" column). The "Resolution" column describes how operators are resolved. If there are multiple function resolutions mentioned in the column, the first one is tried first, if it fails (no matching overload is found), the second one is tried, and so on.

\begin{centeredRefTabular}{c | c | p{6cm}}
	\textbf{Operator} & \textbf{Enum} & \textbf{Resolution} \\ \hline \hline
	
	\inlineCode{x(args)} & & \inlineCode{x.#call(args)} \\
	\hline
	
	\inlineCode{x!} & \inlineCode{suffNot} & \multirow{2}{*}{\inlineCode{x.#opSuffix( op )}} \\
	\inlineCode{x?} & \inlineCode{suffRef} & \\
	\hline
	
	\inlineCode{!x} & \inlineCode{preNot} & \inlineCode{x.#opPrefix( op )} \\
	\hline
	
	\inlineCode{x * y} & \inlineCode{binMult} & \multirow{12}{*}{\parbox{\textwidth}{
		\inlineCode{x.#opBinary( op, y )} \\
		\inlineCode{y.#opBinaryR( op, x )}
	}} \\
	\inlineCode{x / y} & \inlineCode{binDiv} & \\
	\cline{1-2}
	
	\inlineCode{x + y} & \inlineCode{binPlus} & \\
	\inlineCode{x - y} & \inlineCode{binMinus} & \\
	\cline{1-2}
	
	\inlineCode{x != y} & \inlineCode{binNeq} & \\
	\inlineCode{x < y} & \inlineCode{binLt} & \\
	\inlineCode{x <= y} & \inlineCode{binLte} & \\
	\inlineCode{x == y} & \inlineCode{binEq} & \\
	\inlineCode{x >= y} & \inlineCode{binGte} &  \\
	\inlineCode{x > y} & \inlineCode{binGt} & \\
	\cline{1-2}
	
	\inlineCode{x && y} & \inlineCode{binLogAnd} & \\
	\inlineCode{x || y} & \inlineCode{binLogOr} & \\
	\hline
	
	\inlineCode{x = y} & \inlineCode{assign} & \inlineCode{x.#assign( y )} \\
	\hline
	
	\inlineCode{x := y} & \inlineCode{refAssign} & \inlineCode{x.#refAssign( y )} \\
	\hline
	
\end{centeredRefTabular}

\section{Variable declarations} \label{varDecls}
\begin{grammar}
	\grDef{VarDeclStmt} \{ \gr{Decoration} \} \gr{TypeExpr} \token{Identifier} \\
		\grLn [ ( \kwd{=} | \kwd{:=} ) \gr{Expression} ] \kwd{;} \\
	\grDef{TypeExpr} \gr{PrefixExpr}
\end{grammar}

Declaring a variable is a thing well known from other programming languages. Declaring a variable consists of two tasks:
\begin{compactenum}
	\item Allocating space for it (heap or stack)
	\item Calling the constructor -- evaluating \inlineCode{var.#ctor( args );}
\end{compactenum}

There are multiple ways of how to construct a variable:
\begin{compactenum}
	\item \inlineCode{Type var;} \quad allocates a variable on the stack and calls \inlineCode{var.#ctor()}
	\item \label{vardecl:opt1} \inlineCode{Type var = val;} allocates a variable on the stack and calls \inlineCode{var.#ctor( val )}
	\item \label{vardecl:opt2} \inlineCode{Type var := val;} allocates a variable on the stack and calls\\\inlineCode{var.#ctor( Operator.refAssign, val )} %TODO change first argument to something more reasonable (singleton?)
	\item \inlineCode{Type( arg1, arg2 )} allocates a temporary variable on the stack, calls\\\inlineCode{tmpVar.#ctor( arg1, arg2 )} and returns the variable
	\item \label{vardecl:opt3} \inlineCode{new Type( arg1, arg2 )} allocates a variable on the heap, calls\\\inlineCode{heapVar.#ctor( arg1, arg2 )}, and returns pointer to the variable
\end{compactenum}

\paragraph{\inlineCode{auto} keyword}
When using \inlineCode{auto} instead of type, variable type is inferred from the value provided (this applies to variants \ref{vardecl:opt1} and \ref{vardecl:opt2}). For dynamic construction (variant \ref{vardecl:opt3}), type is inferred from type the expression is expected to be of.

\begin{code}
auto var = true; // true is Bool, so var is of type Bool
Int? ref := new auto(); // ref constructor expects the Int? type, so auto is inferred as Int
\end{code}

\paragraph{\inlineCode{@ctime} variables}
Variable declarations can be decorated with the \inlineCode{@ctime} decorator. \inlineCode{@ctime} variables are completely evaluated at compile time. For more information, see \autoref{ctime}.

\paragraph{Variable lifetime (extent)} Variable lifetime is same as in C++ or D -- local variables exist until end of the scope (or \inlineCode{return}, \inlineCode{break}, exception, ...), where the are destroyed in reverse order they were defined. Dynamically constructed variables exist until they are manually destroyed (usually done via \gr{DeleteStmt}). Static variables are constructed during application start and are never destroyed (probably will change in the future).

\chapter{Functions}
\begin{grammar}
	\grDef{FunctionDecl} \gr{TypeExpr} \token{Identifier} \gr{ParentCommaExpr} \gr{CodeBlock} \\
	\grDef{CodeBlock} \{ \gr{Decoration} \} \kwd{\{} \{ \gr{Statement} \} \kwd{\}} \\
	\grDef{Statement} \gr{CodeBlock} \\
		\grAltLn \gr{ReturnStmt} \\
		\grAltLn \gr{BreakStmt} \\
		\grAltLn \gr{IfStmt} \\
		\grAltLn \gr{WhileStmt} \\
		\grAltLn \gr{DeleteStmt} \\
		\grAltLn \gr{Expression} \\
		\grAltLn \gr{VarDeclStmt} \\
	\\
	\grDef{ReturnStmt} \kwd{return} \gr{Expression} \kwd{;} \\
	\grDef{BreakStmt} \kwd{break} \kwd{;} \\
	\grDef{IfStmt} \{ \gr{Decoration} \} \kwd{if} \kwd{(} \gr{Expression} \kwd{)} \gr{Statement} \\
		\grLn [ \kwd{else} \gr{Statement} ] \\
	\grDef{WhileStmt} \kwd{while} \kwd{(} \gr{Expression} \kwd{)} \gr{Statement} \\
	\grDef{DeleteStmt} \kwd{delete} \gr{Expression} \kwd{;} \\
\end{grammar}

\section{Function definitions}
Functions in Beast are similar to those in the D programming language. You do not have to write declaration before definition.

\begin{code}
Void foo() {}

Void foo2() {
	foo();
}
\end{code}

When declaring a parameter, you can access all parameters already declared in the parameter list (to declare a parameter, you can utilize all parameters to the left). In return type expression, you can access all function parameters.

\begin{code}
b.#type foo( Int a, a.#type b, a.#type c ) {
	// code
}
\end{code}

\subsection{\inlineCode{auto} return type}
Function return type can be declared as \inlineCode{auto}. In that case, return type is inferred as a data type of the first \inlineCode{return} statement expression in the function code. If there are no return statements, return type is \inlineCode{Void}.

\begin{code}
auto foo() {
	return 5; // return type is deduced to be Int
}
\end{code}

\subsection{Constant-value parameters}
It is possible to declare a parameter that accepts one exact value of a defined type (implicit casting is allowed). This is achieved by instead of using variable declaration syntax, pure expression is inserted to the parameter list. The value must me known at compile time, same as argument value when calling the function. Const-value parameter value and provided argument value are compared bit-by-bit. 

This construct is useful for a \ctime parameter specialization or to differentiate between two overloads with otherwise same parameter types. It is also used when overloading operators.

\begin{code}[Example of constant-value parameters. Please note that there is no \inlineCode{String} in Beast so far, neither user-defined enums]
class Stream {
	// CreateFrom.fromFile and .fromFile are const-value parameters
	Void #ctor( CreateFrom.fromFile, String filename ) { /* ... */ }
	Void #ctor( CreateFrom.fromString, String str ) { /* ... */ } 
}

Void main() {
	// :ident construct is supported with const-value parameters
	Stream str1 = Stream( :fromFile, "file.txt" );
	Stream str2 = Stream( :fromString, "asdfgh" );
}
\end{code}

\begin{code}
class C {
	
	// Operator.binPlus is a const-value parameter
	C #opBinary( Operator.binPlus, C? other ) {
		...	
	}
	
}
\end{code}

\subsection{\ctime parameters}
Static functions (class member functions currently not) can also have \ctime parameters -- parameters decorated with the \inlineCode{@ctime} decorator (see \autoref{ctime}). Effectively, \ctime parameters are similar to template parameters in languages like C++, D or Java.

\begin{code}
auto max( @ctime Type T, T a, T b ) {
	if( a > b )
		return a;
	else
		return b;
}
	
Void main() {
	print( max( Int, 5, 3 ) );
}
\end{code}

\subsection{The \kwd{auto} keyword}
It is possible to declare a parameter as \inlineCode{auto} type. In that case, type of the parameter is deduced from provided argument type. This effectively creates a hidden \inlineCode{@ctime Type} variable, so functions with \inlineCode{auto} parameters cannot be declared as member functions (for now).

\begin{code}
auto max( auto a, a.#type b ) {
	if( a > b )
		return a;
	else
		return b;
}

Void main() {
	print( max( 5, 3 ) );
}
\end{code}

\section{Compiler-defined functions}
There are currently these functions static defined by the compiler:

\paragraph{\inlineCode{print} functions}

\begin{code}
Void print( Bool data )
Void print( Int32 data )
Void print( Int64 data )
\end{code}
These functions print provided argument to the stdout as signed decimals (\inlineCode{true} is printed as \inlineCode{1} and \inlineCode{false} as 0). Calling these functions at compile time results in an error.

\paragraph{\inlineCode{assert}}

\begin{code}
void assert( Bool expr )
\end{code}
Does nothing if provided argument is \inlineCode{true}. If \inlineCode{expr} is \inlineCode{false}, creates an error (compiler error at compile time, prints text to stderr and exits the program at runtime).

\paragraph{\inlineCode{malloc}, \inlineCode{free}}

\begin{code}
	Pointer malloc( Size bytes )
	Void free( Pointer ptr )
\end{code}
Allocates/deallocates a memory on the heap. This function is also callable at compile time.

\chapter{Types}

\begin{grammar}
	\grDef{ClassDecl} \kwd{class} \token{Identifier} \kwd{\{} \gr{DeclScope} \kwd{\}}
\end{grammar}

Currently, Beast only supports classes. There are also compiler-defined enums, but there's currently no syntactic support for user-defined enumerations.

\section{Class declarations}
Classes do not support inheritance at all (is to change in the future). No automatic constructor or destructor generation is implemented either, a programmer must manually write class constructors and destructors and call member constructors and destructors in them. It is important to call member constructors/destructors, especially for reference types. Constructors are declared as \inlineCode{Void #ctor( args )} and destructors as \inlineCode{Void #dtor()}.

For more info about constructor and destructor calls, see \autoref{varDecls}.

For more info about operator overloading, see \autoref{operatorOverloading}.

\begin{code}
class C {

	// Implicit constructor
	Void #ctor() {
		a.#ctor();
		b.#ctor();
	}
	
	// Copy constructor
	Void #ctor( C? other ) {
		a.#ctor( other.a );
		b.#ctor( other.b );	
	}

	// Destructor
	Void #dtor() {
		a.#dtor();
		b.#dtor();	
	}

	Int a;
	Int b;

}
\end{code}

Classes have following fields/functions/properties automatically defined/implemented by the compiler:
\begin{compactenum}
	\item \inlineCode{T?} suffix operator that returns reference type (static call only)
	\item \inlineCode{T!} suffix operator that currently does nothing (returns the class itself; static call only); in future, it will be used as a mutability declarator (Beast will be const-by-default)
	\item Implicit cast to reference
	\item \inlineCode{T( args )} constructing an instance of \inlineCode{T} with provided arguments (static call only; see \autoref{varDecls})
	\item \inlineCode{var.to( Type )} for explicit/implicit casting (see \autoref{typeConversion})
	\item \inlineCode{var.#addr} that returns \inlineCode{Pointer} referencing the variable \inlineCode{var}
	\item \inlineCode{T.#instanceSize} of type \inlineCode{Size} that returns instance size of given type (equivalent to \inlineCode{sizeof} in C++/D)
	\item Comparison operators \inlineCode{T == T2} and \inlineCode{T != T2} for comparing type variables (static call only)
\end{compactenum}

Classes can be considered a \ctime variables of type \inlineCode{Type} (see \autoref{typeType}).

\paragraph{Nested class declarations}
You can declare classes in classes, however you have to decorate the inner class with \inlineCode{@static}. Nested classes do not implicitly store pointer to parent class instance. They can be accessed from outside using \inlineCode{OuterClass.NestedClass}.

\section{Compiler-defined types}
Beast offers a limited amount of pre-defined types.

\subsection{Numeric types}
Beast provides 32-bit and 64-bit signed integer types -- \inlineCode{Int32} (also aliased as \inlineCode{Int}) and \inlineCode{Int64}. Basic arithmetic operators are supported (\inlineCode{+}, \inlineCode{-}, \inlineCode{*}, \inlineCode{/}) and are overloaded in both left and right variants (see \autoref{operatorOverloading}), meaning both expressions like \inlineCode{a + 5} and \inlineCode{5 + a} are supported if \inlineCode{a} is of type implicitly convertible to \inlineCode{Int} (see \autoref{typeConversion}). \inlineCode{Int32} is implicitly castable to \inlineCode{Int64}.

Beast also has type \inlineCode{Size} which has size of 4 or 8 bytes, depending on a platform. This is a Beast alternative to \inlineCode{size_t}.

\subsection{Reference types}
Beast offers reference type \inlineCode{T?} (where \inlineCode{T} is the referenced type) and pointer type \inlineCode{Pointer}. \inlineCode{Pointer} is not bound to a type, referenced data is manipulated via \inlineCode{T ptr.data( @ctime Type T )}.  You cannot have reference of a reference.

For most cases, reference is the way to go. It acts like referenced type, except for following cases:
\begin{compactitem}
	\item \inlineCode{ref.#ctor} and \inlineCode{ref.#dtor} calls reference constructor, not referenced type constructor.
	\item \inlineCode{ref := var} operator is overloaded and is used for changing the referenced variable
	\item Reference is implicitly castable to \inlineCode{Pointer}
	\item A \inlineCode{isNull} property is added (use as \inlineCode{ref.isNull}, not \inlineCode{ref.isNull()}) which returns if a reference references a variable or not
	\item A \inlineCode{@ctime Type ref.#baseType} property is added that stores the referenced type
	\item A \inlineCode{ref.#data} alias is added, which allows direct access to referenced variable namespace. This is useful for example when a programmer needs to manually call referenced value constructor/destructor (please note that it is usually dangerous) -- he would use \inlineCode{ref.#data.}\-\inlineCode{#dtor()}, because \inlineCode{ref.#dtor()} would call the reference destructor, not the referenced value one.
\end{compactitem}
\pagebreak

\begin{centeredRefTabular}{l | c | c}
	\textbf{Property} & \textbf{Reference} & \textbf{Pointer} \\ \hline \hline
	
	Pointer arithmetics & no & (in future) \\ \hline
	Can be \inlineCode{null} & yes & yes \\ \hline
	Rebindable & yes & yes \\ \hline
	Binding & \inlineCode{ref := val} & \inlineCode{ptr = val.#addr} \\
		& or \inlineCode{ref := ref2} & \\ \hline
	Member access & \inlineCode{ref.mem} & \inlineCode{ptr.data( Type ).mem} \\ \hline
	Dereference & (implicit cast) & \inlineCode{ptr.data( Type )} \\
\end{centeredRefTabular}

\begin{code}
Int x = 5;
Int y = 6;

// ref now references variable x
Int? ref := x;
print( ref ); // prints 5
ref = 10; // x is set to 10

xref := y; // ref now references variable y
print( ref ); // prints 6
ref = 7; // y is is set to 7
\end{code}

\begin{code}
Int x = 5;
Int y = 6;

// ptr now references variable x
Pointer ptr = x.#addr;
print( ptr.data( Int ) ); // prints 5
ptr.data( Int ) = 10; // x is set to 10

ptr = y.#addr; // ptr now references variable y
print( ptr.data( Int ) ); // prints 6
ptr.data( Int ) = 7; // y is is set to 7
\end{code}

\subsection{\inlineCode{Type} type} \label{typeType}
Types (classes, enums, ...) are considered \ctime variables of type \inlineCode{Type}. Type variables can only be used as \ctime variables.

\begin{code}
@ctime Type T! = Int;
T x = 5;

@ctime T := Bool;
T y = true;
\end{code}

\chapter{Modules}
\begin{grammar}
	\grDef{ModuleEntry} \kwd{module} \gr{ModuleIdentifier} \kwd{;} \{ \gr{ModuleLvlDecl} \} \\
	\grDef{ModuleIdentifier} \token{Identifier} \{ \kwd{.} \token{Identifier} \} \\
	\\
	\grDef{ModuleLvlDecl} \gr{ModuleLvlDeclBlock} \\
		\grAltLn \gr{ImportStmt} \\
		\grAltLn \gr{FunctionDecl} \\
		\grAltLn \gr{ScopeDecorationStmt} \\
		\grAltLn \gr{ModuleLvlDeclBlock} \\
	\grDef{ScopeDecorationStmt} \{ \gr{Decoration} \}+ \kwd{:} \\
	\grDef{ModuleLvlDeclBlock} \{ \gr{Decoration} \} \kwd{\{} \gr{ModuleLvlDecl} \kwd{\}} \\
\end{grammar}

The program is divided into modules. Each module begins with a module declaration statement.
\begin{code}
module package.package.moduleName;
\end{code}

The \gr{ModuleIdentifier} in the \gr{ModuleEntry} then works as an identifier for the module. Multiple modules with the same identifier are not allowed.

\paragraph{Filesystem representation} Module identifier has to correspond with the directory structure the source file is in and the source file name has to be same as the module name (case sensitive). For example, having set up \verb|project/src| and \verb|project/include| source file directories, module \verb|straw.beast.main| has to be in file \verb|project/src/straw/beast/main.beast| or \verb|project/include/straw/beast/main.beast|.

\paragraph{Naming convention} Modules should be named in lower-CamelCase. This is not enforced, however disobeying this rule results in a warning.

\chapter{Decorators}
%TODO noWarning, final, abstract, base, virtual, override, static, noScope, virtualBase

\begin{grammar}
	\grDef{Decoration} \kwd{@} \token{Identifier}
\end{grammar}

Generally, decorators provide syntax support for altering properties of types, declarations or even blocks of code.

\section{Decorator application}
At module level, there are three ways of how to apply a decorator:
\begin{code}
module a;

class C {
	
// Scope decoration
@decoratorA @decoratorB:
	Int32 d;
	Int64 c;
	
	// Block decoration
	@decoratorE @decoratorF {
		Int8! b;
		Int16! c;	
	}
	
	// Statement decoration
	@decoratorC @decoratorD Int8! a;
				
}
\end{code}

\paragraph{Scope decorations} Decorators are applied to all statements following the decoration up to next scope decoration or current scope end. You cannot use scope decorations directly in the module root scope.

\paragraph{Block decorations} Decorators are applied to all statements in the block.

\paragraph{Statement decorations} Decorators are applied to the statement that follows the decoration.

\subsection{Decoration contexts} \label{decorationContexts}
The concept of decorators wraps up lot of possibilities and functionality. In order to make things work, it is necessary to define different types of decorators, each altering the program in a different, unique way. In Beast, these decorator subtypes are called \textit{decorator contexts}. Each decorator is defined for one particular context. However decorator identifiers are overloadable, so it is possible to define multiple decorators for different contexts with the same name.

The contexts are following (decorators of contexts commented with "system only" cannot be defined by the programmer):
\begin{code}
enum DecorationContext {
	importModifier, // system only
	parameterModifier, // system only
	accessModifier, // system only for now
	metadata, // concept, not fully documented
	fieldWrapper, // concept, not fully documented
	typeWrapper, // concept, not fully documented
	typeMixin, // concept, not fully documented
	functionModifier, // system only
	classDeclarationModifier, // system only
	enumDeclarationModifier, // system only
	variableDeclarationModifier, // system only
	controlStatementModifier, // system only
	codeBlockModifier // system only
}
\end{code} \label{enum:DecorationContext}
%TODO better ordering

%TODO context description
\subsubsection{The 'importModifier' decoration context}

\subsection{Decorator overloading}
Decorators can take parameters, just like functions (\inlineCode{@decoration} is equivalent to \inlineCode{@decoration()}). The behavior is following:
\begin{enumerate}
	\item Overloads that do not match given arguments are ignored
	\item Find overload that has lowest-index context (as ordered in the \enumRef{DecorationContext} enum) and remove overloads that are of different context
	\item Remove those overloads whose list of required implicit casts is superset of any other overload's required implicit cast list in the overloadset
	\begin{itemize}
		\item \inlineCode{auto} arguments are treated as implicit casted
		\item Arguments containing \inlineCode{:ident} accessor are also treated as implicit casted
	\end{itemize}
	\item Apply the only overload remaining (or error)
\end{enumerate}

\paragraph{Decorator ordering by context} In order to improve code readability and programmers' awareness, it is enforced by the compiler that decorations are ordered by the context they're used in (the order is specified in the \enumRef{DecorationContext} enum).

\subsection{Decorator conflicts}
\textbf{You cannot apply two decorators that are incompatible.} The most common case are the \hyperref[accessModifierDecorators]{access modifier decorators}.
\begin{code}
@final class C {

@public:
	@private Int8 a; // Error - @public and @private decorators are incompatible
	
}
\end{code}

\section{Predefined decorators}

\subsection{Import locality modifiers (\decoratorRef{global}, \decoratorRef{local})}
The decorators only support \decorationContextRef{importDecoration} context. See \nameref{imports}.

\subsection{Access modifiers (\decoratorRef{public}, \decoratorRef{private}, \decoratorRef{protected} and \decoratorRef{friend})} \label{accessModifierDecorators}
Access modifier decorators specify where a symbol is accessible from. They only support the \decorationContextRef{moduleLevelDeclaration} context.

\paragraph{\decoratorRef{public}} \label{decorator:public} Symbols with the \decoratorRef{public} access modifier are accessible from everywhere.

\paragraph{\decoratorRef{private}} \label{decorator:private} Symbols with the \decoratorRef{private} access modifier are accessible only from the current scope (and it's subscopes).

\paragraph{\decoratorRef{protected}} \label{decorator:protected} The \decoratorRef{protected} only makes sense when used in classes. It makes symbols accessible from the current scope, its subscopes and any scope that derives from any of its subscopes.

\paragraph{\decoratorRef{friend}} \label{decorator:friend} The \decoratorRef{friend} decorator exclusively allows access to one scope symbol, specified as the parameter. This rule has higher priority than \decoratorRef{protected} or \decoratorRef{private}.

Syntax: \inlineCode{@friend( Symbol friend )}

\begin{code}
class C {
	@private @friend( func3 ) Int8 x;
	@protected Int16 func() {
		return 32000;
	}	
	@public Int32 y;
}

@final class D : @public C {
	
@public:
	Void func2() {
		x = 6; // Error
		func(); // Ok
	}
	
}

Void func3() {
	C c;
	c.x = 5; // Ok - func3 is friend with C.x
	c.func(); // Error
	c.y = 10; // Ok
}
\end{code}

\paragraph{Inter-compatibility}
The \decoratorRef{public}, \decoratorRef{protected} and \decoratorRef{private} decorators are not compatible with any decorator from the three (this also means you can't apply them twice). Also, \decoratorRef{friend} and \decoratorRef{public} decorators are not compatible.

\subsection{The \decoratorRef{ctime} (and \decoratorRef{autoCtime}) decorator} \label{decorator:ctime} \label{decorator:autoCtime}
%TODO rework
Generally, the \decoratorRef{ctime} decorator is related with compile time execution. It supports multiple contexts and depending on the context, its semantics can slightly change.

\paragraph{Axioms overview}
\begin{itemize}
	\item A compile-time variable's value is always known at compile time (=> cannot change during runtime).
	\item A compile-time function is always evaluated at compile time. That implies that parameters must be known at compile time. The return type is also compile-time.
	\item Some runtime functions can be executed at compile time.
	\item There is a difference between a compile-time function and a function executed at compile time.
	\item A compile-time variable is implicitly castable to const runtime variable.
	\item A compile-time class contains compile-time variables.
	\item A compile-time class can contain runtime functions, but those cannot modify class' fields (they can only be const).
\end{itemize}

\paragraph{Compile-time parameters}
A function parameter decorated with \decoratorRef{ctime} is a compile-time parameter.

Compile-time parameter values must always be known at compile time. Compile-time parameters can be mutable.

Technically, a function with compile-time parameter is a function template.

\begin{code}
// 'y' and 't' parameters are compile-time
Void f( Int x, @ctime Int y, @ctime Type t ) {
	
}
\end{code}

For more info, see \nameref{ctime:parameter}.

\paragraph{Compile-time variables}
A variable decorated with \decoratorRef{ctime} is a compile-time variable. Compile-time variables defined in function bodies \textbf{can be mutable} (global compile-time variables cannot be mutable). A compile-time variable can be of a \hyperref[ctime:class]{compile-time type} (a non-compile-time variable cannot be of a~compile-time type). You cannot define a compile-time variable as a dynamic member of a non-compile-time class.

In order to prevent confusion, it is prohibited to work with runtime variables and manipulate (change values of) @ctime variables in the same expression.

\begin{code}
@ctime Type! t = Int; // t is a mutable @ctime variable that can hold types.

t x = 5; // Now we declared a variable x of type t (which is Int). It is a runtime variable.

t = String; // We're changing the @ctime variable here
t str = "asd"; // y is of type String

@ctime t str2 = "lol"; // str2 is compile time variable of type String
\end{code}

For more info, see \nameref{ctime:variable}.

\paragraph{Compile-time functions}
A function decorated with \decoratorRef{ctime} is a compile-time function. A compile-time function is always executed at compile time. It returns a \hyperref[ctime:class]{compile-time type}. Its parameters and all variables used in its body are compile-time.

The \decoratorRef{ctime} decorator should be omitted in parameter, variable and return type declaration; a warning is shown otherwise.

\begin{code}
@ctime Type TypeIntersection( Type t1, Type t2 ) {
	// if t2 is parent of t1
	if( t1 is t2 )
		return t2;
		
	// if t1 is parent of t2
	else if( t2 is t1 )
		return t1;
	
	else
		return Void;
}
\end{code}

For more info, see \nameref{ctime:function}

\paragraph{Compile-time classes}
A class decorated with \decoratorRef{ctime} is a compile-time class. Any instance of a compile-time class is a compile-time instance/variable. All its mutable member functions must be \hyperref[ctime:function]{compile-time functions}, all its member variables are \hyperref[ctime:variable]{compile-time variables} (the \decoratorRef{ctime} decorator should be omitted).

\begin{code}
@final @ctime class MyFunctionInfo {

@public:
	Void #ctor!( Function F ) {
		returnType = F.#returnType;
		parameterTypes = F.#parameters.map( x => x.type );
	}
	
@public:
	Type returnType;
	Type[] parameterTypes;	
	
}
\end{code}

For more info, see \nameref{ctime:class}.

\paragraph{Compile-time control statements}
A control statement decorated with \decoratorRef{ctime} is a compile-time control statement. In a compile-time control statement, \textbf{expressions in the statement are evaluated in compile-time, but the statement bodies are evaluated at runtime}.

All variables declared in the statement expressions are compile-time. They don't need to be decorated with the \decoratorRef{ctime} decorator.

\begin{code}
@ctime Type! t = Int8;

if( 3 == 5 )
	t = Int16; // Warning: compile-time variable modification inside a runtime control statement

// t == Int16 here
\end{code}

\begin{code}
@ctime for( Int16 x = 0; x < 20; x ++ ) {
	// x is a compile-time variable
	writeln( "lol" );
	// The code generated from this would be twenty writeln("lol") calls
}

for( Int16 x = 0; x < 20; x ++ ) {
	// x is a runtime variable, the loop is executed at runtime	
}

@ctime for( Int16 x = 0; x < 20; x ++ ) @ctime {
	// x is a compile-time variable and this entire block is also executed at compile-time (the "lol" is written into compiler console)
	writeln( "lol" );
}

\end{code}

\paragraph{Compile-time code block} A code block decorated with the \decoratorRef{ctime} is executed at compile time. All variables declared in it are compile time and they should not be decorated with the \decoratorRef{ctime} decorator.

\paragraph{The \decoratorRef{autoCtime} decorator} \label{decorator:autoCtime} This decorator works similar to the \decoratorRef{ctime}, except it only makes things compile-time when it is possible.

In \decorationContextRef{classDeclaration} and \decorationContextRef{enumDeclaration}, it makes the type compile-time if it derives from a compile-time type or if it has a nonstatic compile-time member.

In the \decorationContextRef{parameterDeclaration} context, the parameter is made compile-time whenever the function is called with a parameter value that is known at compile time.
\begin{code}
@final class HashTable( Type Key, Type Value ) {

@public:
	// You may ask, that the hell is "T!?!" ?! Don't be scared, T! means a mutable type T, T!? means non-mutable reference to mutable type and T!?! means mutable reference to mutable type (mutable reference == you can change where the reference points to using the ':=' operator)
	T!?! #operator!( Operator("x[args]"), @autoCtime Key key ) {
		Index hash = key.#hash() % tableSize_;	
		
		// Locating the record here 
	}
	
}

Void main() {
	HashTable( String, Int )! table;
	
	table[ stdin.read() ] = 5;
	
	table[ "key" ] = 10;
	// On the previous line the #key parameter is known at compile time, so the function is optimized (the hash calculation is performed at compile time)
}
\end{code}

In the \decorationContextRef{functionDeclaration} context, the function is made compile-time when all of its parameters (all of them must be decorated with \decoratorRef{autoCtime} or \decoratorRef{ctime}) and/or return type are compile time.

In the \decorationContextRef{variableDeclaration} context, the variable is made compile time if its type is compile time.

The decorator cannot be used in any other contexts.

\subsection{The \decoratorRef{noscope} decorator} \label{decorator:noscope}

\chapter{Code hatching concept (\inlineCode{@ctime})} \label{ctime}
Ctime is a powerful concept introduced in Beast. It provides a form of metaprogramming, but that's not all what it does.

\paragraph{Basic idea}
The ctime concept has one simple idea: to introduce a \textbf{type of variables of which value can be deduced at any line of code} (without having to run the program).

These variables will are called ctime variables in Beast.

\paragraph{Consequences} Consequences of this one simple rule are following:

\chapter{Reflection} \label{reflection}

\section{Overloadsets}
\begin{code}
Overloadset #overloadset
Symbol #matchOverload( args )

class Overloadset {
}
\end{code}

\section{Symbols}
\begin{code}
String #identifier
Type #type
SymbolMetadata #symbol

class SymbolMetadata {

}
\end{code}

\section{Classes}
\begin{code}
String #className // Can be null for anonymous classes
ClassMetadata #class
Overloadset #member( String identifier )
Size #instanceSize

class ClassMetadata {
}
\end{code}

\section{Function}
\begin{code}
Type #returnType
Type #returnType( args )
FunctionMetadata #function
Type #argType( Index index )
String #argIdentifier( Index index )
Bool #isVariadic

class FunctionMetadata {
	
@public:
	String identifier;
	
	
}
\end{code}

\chapter{Beast practices \& styling guide}

\begin{itemize}
	\item Class and enum names are in \verb|UpperCamelCase|.
	\item Enum members are in \verb|lowerCamelCase|. They do not contain any enum-related prefixes.
	\item Decorator names are in \verb|lowerCamelCase|.
	\item Variable (and parameter) names are in \verb|lowerCamelCase|, type variables are in\\\verb|UpperCamelCase|.
	\item Function names are in \verb|lowerCamelCase|.
	\item The \verb|_| symbol can be used in identifiers as a separator (for example class\\\verb|PizzaIngredient_Cheese|).
\end{itemize}

\section{Further recommended code style}
\begin{itemize}
	\item Indent with tabs (so anyone can set up tab size based on his preferences)
	\item Spaces in statements like this: \inlineCode{if( expr ) \{}, opening brace on the same line
	\item Spaces around operators: \inlineCode{x + y}
	\item Decorators on the same line with decorated symbols (if the decoration list is too long).
\end{itemize}

\chapter{Plans for the future}
\begin{compactitem}
	\item Aliased imports
	\item Namespaces
	\item User decorators
	\item Blueprints -- "mixin classes" -- bad idea?
	\item Mixins
	\item Mixins but no mixins (not mixing a string, mixing a declaration)
	\item Lambdas
	\item Singletons
	\item Extern functions -- cooperation with other programming languages
	\item Compiler support for documentation comments?
	\item Compiler outputs intellisense data?
	\item Compiler caching
\end{compactitem}

\section{Documentation to-do}
\begin{compactitem}
	\item Virtual functions, when a class is virtual
	\item \decoratorRef{noWarning(W103)}
	\item \decoratorRef{label} (for break, continue nested)
	\item \decoratorRef{notNull}
	\item \verb|#| prefixed identifiers (rules, restrictions) + \verb|to|
	\item \inlineCode{class X : @public @final Y}
	\item Array literals
\end{compactitem}

\end{document}          
