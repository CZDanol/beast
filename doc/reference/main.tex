% !TeX spellcheck = en_US

\include{header}
\include{mainpage}
\include{support}

\setlength\extrarowheight{2pt}

% Title Page
\title{Beast programming language}
\subtitle{Language specification/reference}
\author{Daniel ÄŒejchan}
\date{2016-2017}


\begin{document}
\mainpage
%\renewcommand{\clearpage}{}

\chapter{Table of contents}
{
	\renewcommand{\baselinestretch}{0.7}\normalsize
	\makeatletter
	\setcounter{tocdepth}{1}
	\@starttoc{toc}
	\makeatother
}

\chapter{Introduction}
Beast is an imperative, structured, modular programming language supporting OO and functional paradigms. Currently, only transcompilation to C is available. In future, a LLVM backend integration is planned.

Most notably, the language implements a new concept called \textit{code hatching} (also a subject of this paper) that unifies templating, compile-time function execution, compile-time reflection and metaprogramming in general.

\section{Inspiration}
\paragraph{Inspiration from C++}
\begin{compactitem}
	\item Most of the syntax
\end{compactitem}

\paragraph{Inspiration from D}
\begin{compactitem}
	\item Module system (not implemented yet)
	\item Compile-time function execution
\end{compactitem}

\paragraph{Ideas not directly inspired by other languages}
\begin{compactitem}
	\item Code hatching concept
	\item Language reflection
	\item The \hyperref[colonAccessor]{\kwd{:}} accessor
	\item The \hyperref[constantValueParameter]{constant value function parameters}	
	\item Decorators (not implemented yet)
\end{compactitem}

\chapter{Lexical}
In a normal code, Beast accepts only standard ASCII characters. Non-ascii characters are allowed only in comments.

\begin{grammar}
	\tokenDef{Whitespace} \verb|[\n\t\r ]+|
\end{grammar}

\section{Identifiers}
\begin{grammar}
	\tokenDef{Identifier} \verb|[#a-zA-Z_][a-zA-Z_0-9]*|
\end{grammar}
An identifier consists of any combination of lower and upper case ASCII letters, numbers and undescores, with these additional rules:
\begin{itemize}
	\item An identifier cannot begin with a number.
	\item An identifier can begin with the hasthag (\verb|#|) character. These identifiers are used in various language constructs and can have restrictions of where and how they can be used in declarations.
\end{itemize}

\section{Keywords} \label{keywords}
More keywords will be added in the future.

\begin{code}
auto, break, class, delete, else, if, module, new, return, while
\end{code}

\section{Operators}
\begin{code}
+ - * / ? ! == != > >= < <= && || ! = :=
\end{code}

\section{Special tokens}
\begin{code}
. , @ ( ) { }
\end{code}

\section{Literals}
\begin{grammar}
	\grDef{Literal} \gr{IntLiteral} \\
\end{grammar}

\subsection{Boolean 'literals'}
Beast does provide \inlineCode{true} and \inlineCode{false}, however those are not keywords or literals, but just \decoratorRef{ctime} variables defined from the runtime library. That means that they can be redefined.

\subsection{The 'null' 'literal'}
The \inlineCode{null} is of an unspecified type that is statically implicitly castable to pointer or reference of any type. It is not a keyword; it is defined in runtime library and thus can be redefined.

\subsection{Integer literals}
Integer literal is always of type \inlineCode{Int32}.

\begin{grammar}
	\tokenDef{IntLiteral} \verb|-?[0-9]+| 
\end{grammar}

\section{Comments}
\begin{grammar}
	\tokenDef{LineComment} \verb|//[^\n$][\n$]| \\
	\tokenDef{Comment} \verb|/\*.*?\*/|
\end{grammar}
Additionally, \textbf{comments can be nested}.

\begin{code}
void main() {
	/* This is a comment
		/* This is a comment, too. */
		Still a comment */
	thisIsACode();
}
\end{code}

\chapter{Expressions}
\begin{grammar}
	\grDef{Expression} \gr{AssignExpr} \\		
		\grAltLn \gr{DecoratedExpression} \\
		
	\grDef{ParentCommaExpr} \kwd{(} [ \gr{Expression} \{ \kwd{,} \gr{Expression} \} ] \kwd{)} \\
	
	\grDef{DecoratedExpression} \{ \gr{Decoration} \}+ \gr{AssignExpr} \\
\end{grammar}

\section{Operators}
\begin{grammar}	
	\grDef{AssignExpr} \gr{LogicExpr} \\
		\grAltLn \gr{LogicExpr} \kwd{=} \gr{LogicExpr} \\
		\grAltLn \gr{LogicExpr} \kwd{:=} \gr{LogicExpr} \\
	
	\grDef{LogicExpr} \gr{CmpExpr} \\
		\grAltLn \gr{CmpExpr} \{ \kwd{\&\&} \gr{CmpExpr} \}+ \\
		\grAltLn \gr{CmpExpr} \{ \kwd{||} \gr{CmpExpr} \}+ \\
		
	\grDef{CmpExpr} \gr{SumExpr} \\
		\grAltLn \gr{SumExpr} \kwd{!=} \gr{SumExpr} \\
		\grAltLn \gr{SumExpr} \{ ( \kwd{==} | \kwd{>=} | \kwd{>} ) \gr{SumExpr} \}+ \\
		\grAltLn \gr{SumExpr} \{ ( \kwd{==} | \kwd{<=} | \kwd{<} ) \gr{SumExpr} \}+ \\
		
	\grDef{SumExpr} \gr{MultExpr} \\
		\grAltLn \gr{MultExpr} \{ ( \kwd{+} | \kwd{-} ) \gr{MultExpr} \}+ \\
	
	\grDef{MultExpr} \gr{VarDeclExpr} \\
		\grAltLn \gr{NewExpr} \{ ( \kwd{*} | \kwd{/} ) \gr{NewExpr} \}+ \\
		
	\grDef{NewExpr} \gr{PrefixExpr} \\
		\grAltLn \kwd{new} \gr{PrefixExpr} [ \gr{ParentCommaExpr} ] \\

	\grDef{PrefixExpr} \gr{SuffixExpr} \\
		\grAltLn \kwd{!} \gr{SuffixExpr} \\
		
	\grDef{SuffixExpr} \gr{AtomExpr} \\
		\grAltLn \kwd{auto} \\
		\grAltLn \gr{AtomExpr} \{ \gr{SuffixOp} \}+ \\
	
	\grDef{AtomExpr} [ \kwd{:} ] \token{Identifier} \\
		\grAltLn \gr{Literal} \\
		\grAltLn \gr{Identifier} \\
		\grAltLn \gr{ParentCommaExpr} \\
	
	\grDef{SuffixOp} \gr{ParentCommaExpr} \\
		\grAltLn \kwd{.} \token{Identifier} \\
		\grAltLn \kwd{?} | \kwd{!} \\
		\grAltLn \gr{ParentCommaExpr}
\end{grammar}

\subsection{Operator precedence} \label{opPrecedence} \nopagebreak

\begin{centeredRefTabular}{P{1.5cm} | c | p{6cm} | c}
	\textbf{Priority} & \textbf{Operator} & \textbf{Semantics} & \textbf{Assoc.} \\ \hline \hline
	
	1
		& \inlineCode{x(args)} & Function call & \multirow{7}{*}{L$\rightarrow$R} \\
		& \inlineCode{x.ident} & Member access & \\
		\cline{2-4}
		& \inlineCode{x!} & Mutable type & \\
		& \inlineCode{x?} & Reference type & \\
	\hline
	
	2
		& \inlineCode{!x} & Logical NOT & \multirow{1}{*}{NOCH} \\
	\hline
	
	3
		%& \inlineCode{T id = args} & (not overloadable) & In-expression variable declaration & \multirow{2}{*}{NOCH} \\
		& \inlineCode{new x( args )} & Dynamic construction & NOCH \\
	\hline
	
	4
		& \inlineCode{x * y} & Multiplication & \multirow{2}{*}{L$\rightarrow$R} \\
		& \inlineCode{x / y} & Division \\
	\hline
	
	5
		& \inlineCode{x + y} & Addition & \multirow{2}{*}{L$\rightarrow$R} \\
		& \inlineCode{x - y} & Subtraction & \\
	\hline
	
	6
		& \inlineCode{x != y} & Not equal to & \multirow{1}{*}{NOCH} \\
		\cline{2-4}
		& \inlineCode{x < y} & Less than & \\
		& \inlineCode{x <= y} & Less than or equal to & \multirow{3}{*}{\parbox{1cm}{\centering L$\rightarrow$R\\SPEC}} \\
		& \inlineCode{x == y} & Equal to & \\
		& \inlineCode{x >= y} & Greater than or equal to & \\
		& \inlineCode{x > y} & Less than & \\
	\hline
	
	7
		& \inlineCode{x && y} & Logical AND & \multirow{2}{*}{\parbox{1cm}{\centering L$\rightarrow$R,\\SAME}} \\
		& \inlineCode{x || y} & Logical OR & \\
	\hline
	
	8
		& \inlineCode{x = y} & Assignment & \multirow{2}{*}{\parbox{1cm}{\centering NOCH}} \\
		& \inlineCode{x := y} & Reference assignment & \\
	\hline

\end{centeredRefTabular}

\paragraph{Associativity -- explanation}
\begin{compactitem}
	\item \textbf{L$\rightarrow$R} Operations from the same group are processed from left to right, meaning \inlineCode{x + y + z} is processed as \inlineCode{(x + y) + z}.
	%\item \textbf{R$\rightarrow$L} Operations from the same group are processed from right to left, meaning \inlineCode{x = y = z} is processed as \inlineCode{x = (y = z)}.
	\item \textbf{NOCH} Operations cannot be chained with any operator of the same priority, meaning expressions like \inlineCode{x >> y >> z}, \inlineCode{x >> y << z} or \inlineCode{++!x} are syntactically incorrect.
	\item \textbf{SAME} Only the same operators can be chained, meaning \inlineCode{x & y & z} and \inlineCode{x | y | z} is correct, but \inlineCode{x & y | z} is not.
	\item \textbf{SPEC} Specific chaining rules, described in following sections.
\end{compactitem}

\paragraph{Evaluation order}
Operands are evaluated left to right, if not specified otherwise.

\subsection{Comparison operators chaining} Comparison operators can be chained in monotonous order:

\begin{code}
// (Almost) equivalent with (a > b) && (b >= c) && (c == d) && (d >= e) && (e > f)
a > b >= c == d >= e > f;
// (Almost) equivalent with (a <= b) && (b < c) && (c <= d) && (d == e) && (e < f)
a <= b < c <= d == e < f;
// (Almost) equivalent with (a == b) && (b == c)
a == b == c;
// Syntax error
a > b < c;
\end{code}

When chaining comparison operators, the expressions in form \inlineCode{x == y > z} are internally rewritten to \inlineCode{(x == y) && (x > z)} (supports user overloaded operators), except the \verb|x|, \verb|y| and \verb|z| expressions are evaluated only once.

\section{Overloadsets (symbols, symbol lookup, identifier resolution, overloading)}
Overloadset is a language structure, a container with all symbols that match currently processed expression. Consider following example:

\begin{code}
Void f() {}$\label{codeLine:overloadSets1:fDecl}$

Void main() {
	f();$\label{codeLine:overloadSets1:fCall}$	
}
\end{code}

Here, when processing the function call on line \ref{codeLine:overloadSets1:fCall}, the compiler starts with identifier \inlineCode{f}. It constructs an overloadset which contains the function \inlineCode{f} defined on line \ref{codeLine:overloadSets1:fDecl}. Then, it reads parentheses, so it will look up for operator \inlineCode{x(args)} in the previous overloadset and put everything it has found to a new overloadset. Then, a process which selects the best matching overload is performed (will be described later in this chapter).

Now let's explain that process step by step.

\subsection{Recursive identifier resolution} \label{fullIdentifierResolution}
When there's an expression that starts with an identifier (\gr{AtomExpr}, the \token{Identifier} version), a recursive identifier resolution is performed for it. This is done by searching symbols with the desired identifier in the current scope. If there is no match in the current scope, the compiler looks into parent scope, and so on. As soon as a match is found, the resolution ends, returning an overloadset with all matching symbols in the currently searched scope. If no match is found, an error is shown.

\subsection{Local identifier resolution} \label{scopedIdentifierResolution}
The scoped identifier resolution is similar to the full identifier resolution, except it doesn't look into parent scopes at all.

\subsection{The '\inlineCode{:ident}' accessor} \label{colonAccessor}
This language construct can be used for example in parameter lists. When used, a \textbf{\hyperref[scopedIdentifierResolution]{scoped identifier resolution} is run} instead of the full identifier resolution. Also, \textbf{the resolution is not performed for the current scope but for the scope of an expected data type}. In function calls, the expected data type would be parameter data type. Please mote that operators are also translated into function calls, so this construct works with operators, too.

This of course does not work with \kwd{auto} parameters.

\begin{code}
enum Enum {
	a, b, c, d
}

Void f( Enum e ) {}

Void main() {
	// Following lines are semantically identical
	f( Enum.a );
	f( :a );	
}
\end{code}

\subsection{Overload resolution} \label{overloadResolution}
Overload resolution is performed every time the compiler needs to match arguments to a function overload. The process is performed over an overloadset where all items must be \textit{callables} (meaning they support overload resolution; error is shown otherwise).

Each overload is assigned a "match level" number. Then, the overload with lowest match level is selected; if no overload matches given arguments, an error is shown; if there are more overloads with the same lowest match level, an error is shown. Overload match level is determined as a sum of $2^i$ of the following:

\begin{compactenum}
	\item Implicit cast needed for at least one argument
	\item Inferration needed for at least one anrgument (used \inlineCode{:ident})
	\item Function is static
	\item Function is compiler-defined
	\item General fallback (compiler-defined)
\end{compactenum}

\subsection{Type conversion} \label{typeConversion}
Beast introduces implicit and explicit cast. Implicit cast are used whenever there's mismatch between expected type and the type provided (for example when passing an argument to a function), explicit casting is done using function \inlineCode{to( @ctime Type targetType )} (which also tries implicit casting if there is no explicit cast available).

Implicit casting is realized by calling \inlineCode{var.#implicitCast( TargetType )}, where \inlineCode{TargetType} being the type the cast is intended to. The function has to return value of \inlineCode{TargetType}. Explicit cast is realized by calling \inlineCode{var.#explicitCast( TargetType )} in the same manner.

\section{Operator overloading} \label{operatorOverloading}
Generally, all operators can be overloaded. Most operators are assigned an item in the \inlineCode{Operator} enum. Operator overloading rules are described in the table below; the "Enum" column corresponds with names of the \inlineCode{Operator} enum items (and the \inlineCode{@ctime Operator op} argument in the "Resolution" column). The "Resolution" column describes how operators are resolved. If there are multiple function resolutions mentioned in the column, the first one is tried first, if it fails (no matching overload is found), the second one is tried, and so on.

\begin{centeredRefTabular}{c | c | p{6cm}}
	\textbf{Operator} & \textbf{Enum} & \textbf{Resolution} \\ \hline \hline
	
	\inlineCode{x(args)} & & \inlineCode{x.#call(args)} \\
	\hline
	
	\inlineCode{x!} & \inlineCode{suffNot} & \multirow{2}{*}{\inlineCode{x.#opSuffix( op )}} \\
	\inlineCode{x?} & \inlineCode{suffRef} & \\
	\hline
	
	\inlineCode{!x} & \inlineCode{preNot} & \inlineCode{x.#opPrefix( op )} \\
	\hline
	
	\inlineCode{x * y} & \inlineCode{binMult} & \multirow{12}{*}{\parbox{\textwidth}{
		\inlineCode{x.#opBinary( op, y )} \\
		\inlineCode{y.#opBinaryR( op, x )}
	}} \\
	\inlineCode{x / y} & \inlineCode{binDiv} & \\
	\cline{1-2}
	
	\inlineCode{x + y} & \inlineCode{binPlus} & \\
	\inlineCode{x - y} & \inlineCode{binMinus} & \\
	\cline{1-2}
	
	\inlineCode{x != y} & \inlineCode{binNeq} & \\
	\inlineCode{x < y} & \inlineCode{binLt} & \\
	\inlineCode{x <= y} & \inlineCode{binLte} & \\
	\inlineCode{x == y} & \inlineCode{binEq} & \\
	\inlineCode{x >= y} & \inlineCode{binGte} &  \\
	\inlineCode{x > y} & \inlineCode{binGt} & \\
	\cline{1-2}
	
	\inlineCode{x && y} & \inlineCode{binLogAnd} & \\
	\inlineCode{x || y} & \inlineCode{binLogOr} & \\
	\hline
	
	\inlineCode{x = y} & \inlineCode{assign} & \inlineCode{x.#assign( y )} \\
	\hline
	
	\inlineCode{x := y} & \inlineCode{refAssign} & \inlineCode{x.#refAssign( y )} \\
	\hline
	
\end{centeredRefTabular}

\section{Variable declarations} \label{varDecls}
\begin{grammar}
	\grDef{VarDeclStmt} \{ \gr{Decoration} \} \gr{TypeExpr} \token{Identifier} \\
		\grLn [ ( \kwd{=} | \kwd{:=} ) \gr{Expression} ] \kwd{;} \\
	\grDef{TypeExpr} \gr{PrefixExpr}
\end{grammar}

Declaring a variable is a thing well known from other programming languages. Declaring a variable consists of two tasks:
\begin{compactenum}
	\item Allocating space for it (heap or stack)
	\item Calling the constructor -- evaluating \inlineCode{var.#ctor( args );}
\end{compactenum}

There are multiple ways of how to construct a variable:
\begin{compactenum}
	\item \inlineCode{Type var;} \quad allocates a variable on the stack and calls \inlineCode{var.#ctor()}
	\item \label{vardecl:opt1} \inlineCode{Type var = val;} allocates a variable on the stack and calls \inlineCode{var.#ctor( val )}
	\item \label{vardecl:opt2} \inlineCode{Type var := val;} allocates a variable on the stack and calls\\\inlineCode{var.#ctor( Operator.refAssign, val )} %TODO change first argument to something more reasonable (singleton?)
	\item \inlineCode{Type( arg1, arg2 )} allocates a temporary variable on the stack, calls\\\inlineCode{tmpVar.#ctor( arg1, arg2 )} and returns the variable
	\item \label{vardecl:opt3} \inlineCode{new Type( arg1, arg2 )} allocates a variable on the heap, calls\\\inlineCode{heapVar.#ctor( arg1, arg2 )}, and returns pointer to the variable
\end{compactenum}

\paragraph{\inlineCode{auto} keyword}
When using \inlineCode{auto} instead of type, variable type is inferred from the value provided (this applies to variants \ref{vardecl:opt1} and \ref{vardecl:opt2}). For dynamic construction (variant \ref{vardecl:opt3}), type is inferred from type the expression is expected to be of.

\begin{code}
auto var = true; // true is Bool, so var is of type Bool
Int? ref := new auto(); // ref constructor expects the Int? type, so auto is inferred as Int
\end{code}

\paragraph{\decoratorRef{ctime} variables}
Variable declarations can be decorated with the \decoratorRef{@ctime} decorator. \ctime variables are completely evaluated at compile time. For more information, see \autoref{ctime}.

\paragraph{Variable lifetime (extent)} Variable lifetime is same as in C++ or D -- local variables exist until end of the scope (or \inlineCode{return}, \inlineCode{break}, exception, ...), where the are destroyed in reverse order they were defined. Dynamically constructed variables exist until they are manually destroyed (usually done via \gr{DeleteStmt}). Static variables are constructed during application start and are never destroyed (probably will change in the future).

\chapter{Functions}
\begin{grammar}
	\grDef{FunctionDecl} \{ \gr{Decoration} \} \gr{TypeExpr} \token{Identifier} \gr{ParentCommaExpr} \gr{CodeBlock} \\
	\grDef{CodeBlock} \{ \gr{Decoration} \} \kwd{\{} \{ \gr{Statement} \} \kwd{\}} \\
	\grDef{Statement} \gr{CodeBlock} \\
		\grAltLn \gr{ReturnStmt} \\
		\grAltLn \gr{BreakStmt} \\
		\grAltLn \gr{IfStmt} \\
		\grAltLn \gr{WhileStmt} \\
		\grAltLn \gr{DeleteStmt} \\
		\grAltLn \gr{Expression} \\
		\grAltLn \gr{VarDeclStmt} \\
	\\
	\grDef{ReturnStmt} \kwd{return} \gr{Expression} \kwd{;} \\
	\grDef{BreakStmt} \kwd{break} \kwd{;} \\
	\grDef{IfStmt} \{ \gr{Decoration} \} \kwd{if} \kwd{(} \gr{Expression} \kwd{)} \gr{Statement} \\
		\grLn [ \kwd{else} \gr{Statement} ] \\
	\grDef{WhileStmt} \kwd{while} \kwd{(} \gr{Expression} \kwd{)} \gr{Statement} \\
	\grDef{DeleteStmt} \kwd{delete} \gr{Expression} \kwd{;} \\
\end{grammar}

\section{Function definitions}
Functions in Beast are similar to those in the D programming language. You do not have to write declaration before definition.

\begin{code}
Void foo() {}

Void foo2() {
	foo();
}
\end{code}

When declaring a parameter, you can access all parameters already declared in the parameter list (to declare a parameter, you can utilize all parameters to the left). In return type expression, you can access all function parameters.

\begin{code}
b.#type foo( Int a, a.#type b, a.#type c ) {
	// code
}
\end{code}

\subsection{\inlineCode{auto} return type}
Function return type can be declared as \inlineCode{auto}. In that case, return type is inferred as a data type of the first \inlineCode{return} statement expression in the function code. If there are no return statements, return type is \inlineCode{Void}.

\begin{code}
auto foo() {
	return 5; // return type is deduced to be Int
}
\end{code}

\subsection{Constant-value parameters}
It is possible to declare a parameter that accepts one exact value of a defined type (implicit casting is allowed). This is achieved by instead of using variable declaration syntax, pure expression is inserted to the parameter list. The value must me known at compile time, same as argument value when calling the function. Const-value parameter value and provided argument value are compared bit-by-bit. 

This construct is useful for a \ctime parameter specialization or to differentiate between two overloads with otherwise same parameter types. It is also used when overloading operators.

\begin{code}[Example of constant-value parameters. Please note that there is no \inlineCode{String} in Beast so far, neither user-defined enums]
class Stream {
	// CreateFrom.fromFile and .fromFile are const-value parameters
	Void #ctor( CreateFrom.fromFile, String filename ) { /* ... */ }
	Void #ctor( CreateFrom.fromString, String str ) { /* ... */ } 
}

Void main() {
	// :ident construct is supported with const-value parameters
	Stream str1 = Stream( :fromFile, "file.txt" );
	Stream str2 = Stream( :fromString, "asdfgh" );
}
\end{code}

\begin{code}
class C {
	
	// Operator.binPlus is a const-value parameter
	C #opBinary( Operator.binPlus, C? other ) {
		...	
	}
	
}
\end{code}

\subsection{\ctime parameters} \label{function:ctimeParams}
Static functions (class member functions currently not) can also have \ctime parameters -- parameters decorated with the \ctime decorator (see \autoref{ctime}). Effectively, \ctime parameters are similar to template parameters in languages like C++, D or Java.

\begin{code}
auto max( @ctime Type T, T a, T b ) {
	if( a > b )
		return a;
	else
		return b;
}
	
Void main() {
	print( max( Int, 5, 3 ) );
}
\end{code}

\subsection{The \kwd{auto} keyword}
It is possible to declare a parameter as \inlineCode{auto} type. In that case, type of the parameter is deduced from provided argument type. This effectively creates a hidden \inlineCode{@ctime Type} variable, so functions with \inlineCode{auto} parameters cannot be declared as member functions (for now).

\begin{code}
auto max( auto a, a.#type b ) {
	if( a > b )
		return a;
	else
		return b;
}

Void main() {
	print( max( 5, 3 ) );
}
\end{code}

\section{Statements}
Statements work very much like in C++/D, so they are not described here.

Only thing needed to specify is that \inlineCode{new} and \inlineCode{delete} operators work with references, not pointers.

\section{Compiler-defined functions} \label{compilerFunctions}
There are currently these functions static defined by the compiler:

\paragraph{\inlineCode{print} functions}~

\begin{code}
Void print( Bool data )
Void print( Int32 data )
Void print( Int64 data )
\end{code}
These functions print provided argument to the stdout as signed decimals (\inlineCode{true} is printed as \inlineCode{1} and \inlineCode{false} as 0). Calling these functions at compile time results in an error.

\paragraph{\inlineCode{assert}}~

\begin{code}
void assert( Bool expr )
\end{code}
Does nothing if provided argument is \inlineCode{true}. If \inlineCode{expr} is \inlineCode{false}, creates an error (compiler error at compile time, prints text to stderr and exits the program at runtime).

\paragraph{\inlineCode{malloc}, \inlineCode{free}}~

\begin{code}
	Pointer malloc( Size bytes )
	Void free( Pointer ptr )
\end{code}
Allocates/deallocates a memory on the heap. This function is also callable at compile time.

\chapter{Types}

\begin{grammar}
	\grDef{ClassDecl} \{ \gr{Decoration} \} \kwd{class} \token{Identifier} \kwd{\{} \gr{DeclScope} \kwd{\}}
\end{grammar}

Currently, Beast only supports classes. There are also compiler-defined enums, but there's currently no syntactic support for user-defined enumerations.

\section{Class declarations}
Classes do not support inheritance at all (is to change in the future). No automatic constructor or destructor generation is implemented either, a programmer must manually write class constructors and destructors and call member constructors and destructors in them. It is important to call member constructors/destructors, especially for reference types. Constructors are declared as \inlineCode{Void #ctor( args )} and destructors as \inlineCode{Void #dtor()}.

For more info about constructor and destructor calls, see \autoref{varDecls}.

For more info about operator overloading, see \autoref{operatorOverloading}.

\begin{code}
class C {

	// Implicit constructor
	Void #ctor() {
		a.#ctor();
		b.#ctor();
	}
	
	// Copy constructor
	Void #ctor( C? other ) {
		a.#ctor( other.a );
		b.#ctor( other.b );	
	}

	// Destructor
	Void #dtor() {
		a.#dtor();
		b.#dtor();	
	}

	Int a;
	Int b;

}
\end{code}

Classes have following fields/functions/properties automatically defined/implemented by the compiler:
\begin{compactenum}
	\item \inlineCode{T?} suffix operator that returns reference type (static call only)
	\item \inlineCode{T!} suffix operator that currently does nothing (returns the class itself; static call only); in future, it will be used as a mutability declarator (Beast will be const-by-default)
	\item Implicit cast to reference
	\item \inlineCode{T( args )} constructing an instance of \inlineCode{T} with provided arguments (static call only; see \autoref{varDecls})
	\item \inlineCode{var.to( Type )} for explicit/implicit casting (see \autoref{typeConversion})
	\item \inlineCode{var.#addr} that returns \inlineCode{Pointer} referencing the variable \inlineCode{var}
	\item \inlineCode{T.#instanceSize} of type \inlineCode{Size} that returns instance size of given type (equivalent to \inlineCode{sizeof} in C++/D)
	\item Comparison operators \inlineCode{T == T2} and \inlineCode{T != T2} for comparing type variables (static call only)
\end{compactenum}

Classes can be considered a \ctime variables of type \inlineCode{Type} (see \autoref{typeType}).

\paragraph{Nested class declarations}
You can declare classes in classes, however you have to decorate the inner class with \inlineCode{@static}. Nested classes do not implicitly store pointer to parent class instance. They can be accessed from outside using \inlineCode{OuterClass.NestedClass}.

\section{Compiler-defined types}
Beast offers a limited amount of pre-defined types.

\subsection{\inlineCode{Bool}}
\inlineCode{Bool} is a 1-byte boolean type. Supported operators are \inlineCode{&& || == !=}. Constants \inlineCode{true} and \inlineCode{false} are provided by the core library.

\subsection{Numeric types}
Beast provides 32-bit and 64-bit signed integer types -- \inlineCode{Int32} (also aliased as \inlineCode{Int}) and \inlineCode{Int64}. Basic arithmetic operators are supported (\inlineCode{+}, \inlineCode{-}, \inlineCode{*}, \inlineCode{/}) and are overloaded in both left and right variants (see \autoref{operatorOverloading}), meaning both expressions like \inlineCode{a + 5} and \inlineCode{5 + a} are supported if \inlineCode{a} is of type implicitly convertible to \inlineCode{Int} (see \autoref{typeConversion}). \inlineCode{Int32} is implicitly castable to \inlineCode{Int64}.

Beast also has type \inlineCode{Size} which has size of 4 or 8 bytes, depending on a platform. This is a Beast alternative to \inlineCode{size_t}.

\subsection{Reference types}
Beast offers reference type \inlineCode{T?} (where \inlineCode{T} is the referenced type) and pointer type \inlineCode{Pointer}. \inlineCode{Pointer} is not bound to a type, referenced data is manipulated via \inlineCode{T ptr.data( @ctime Type T )}.  You cannot have reference of a reference.

For most cases, reference is the way to go. It acts like referenced type, except for following cases:
\begin{compactitem}
	\item \inlineCode{ref.#ctor} and \inlineCode{ref.#dtor} calls reference constructor, not referenced type constructor.
	\item \inlineCode{ref := var} operator is overloaded and is used for changing the referenced variable
	\item Reference is implicitly castable to \inlineCode{Pointer}
	\item A \inlineCode{isNull} property is added (use as \inlineCode{ref.isNull}, not \inlineCode{ref.isNull()}) which returns if a reference references a variable or not
	\item A \inlineCode{@ctime Type ref.#baseType} property is added that stores the referenced type
	\item A \inlineCode{ref.#data} alias is added, which allows direct access to referenced variable namespace. This is useful for example when a programmer needs to manually call referenced value constructor/destructor (please note that it is usually dangerous) -- he would use \inlineCode{ref.#data.}\-\inlineCode{#dtor()}, because \inlineCode{ref.#dtor()} would call the reference destructor, not the referenced value one.
\end{compactitem}

\begin{centeredRefTabular}{l | c | c}
	\textbf{Property} & \textbf{Reference} & \textbf{Pointer} \\ \hline \hline
	
	Pointer arithmetics & no & (in future) \\ \hline
	Can be \inlineCode{null} & yes & yes \\ \hline
	Rebindable & yes & yes \\ \hline
	Binding & \inlineCode{ref := val} & \inlineCode{ptr = val.#addr} \\
		& or \inlineCode{ref := ref2} & \\ \hline
	Member access & \inlineCode{ref.mem} & \inlineCode{ptr.data( Type ).mem} \\ \hline
	Dereference & (implicit cast) & \inlineCode{ptr.data( Type )} \\
\end{centeredRefTabular}

\begin{code}
Int x = 5;
Int y = 6;

// ref now references variable x
Int? ref := x;
print( ref ); //! stdout: 5
ref = 10; // x is set to 10

xref := y; // ref now references variable y
print( ref ); //! stdout: 6
ref = 7; // y is is set to 7
\end{code}

\begin{code}
Int x = 5;
Int y = 6;

// ptr now references variable x
Pointer ptr = x.#addr;
print( ptr.data( Int ) ); //! stdout: 5
ptr.data( Int ) = 10; // x is set to 10

ptr = y.#addr; // ptr now references variable y
print( ptr.data( Int ) ); //! stdout: 6
ptr.data( Int ) = 7; // y is is set to 7
\end{code}

\subsection{\inlineCode{Type} type} \label{typeType}
Types (classes, enums, ...) are considered \ctime variables of type \inlineCode{Type}. Type variables can only be used as \ctime variables. \nopagebreak

\begin{code}
@ctime Type T! = Int;
T x = 5;

@ctime T := Bool;
T y = true;
\end{code}

\chapter{Modules}
\begin{grammar}
	\grDef{ModuleDecl} \kwd{module} \gr{ExtIdentifier} \kwd{;} \{ \gr{DeclScope} \} \\
	\grDef{ExtIdentifier} \token{Identifier} \{ \kwd{.} \token{Identifier} \} \\
	\\
	\grDef{DeclScope} \gr{ClassDecl} \\
		\grAltLn \gr{FunctionDecl} \\
		\grAltLn \gr{ScopeDecorationStmt} \\
		\grAltLn \gr{DeclBlock} \\
	\grDef{ScopeDecorationStmt} \{ \gr{Decoration} \}+ \kwd{:} \\
	\grDef{DeclBlock} \{ \gr{Decoration} \} \kwd{\{} \gr{DeclScope} \kwd{\}} \\
\end{grammar}

The program is divided into modules. Each module begins with a module declaration statement.
\begin{code}
module package.package.modulename;
\end{code}

The \gr{ExtIdentifier} in the \gr{ModuleDecl} then works as an identifier for the module. Multiple modules with the same identifier are not allowed.

Although Beast supports modules, there are currently no imports between them supported.

\paragraph{Filesystem representation} Module identifier has to correspond with the directory structure the source file is in and the source file name has to be same as the module name (case sensitive). For example, having set up \verb|project/src| and \verb|project/include| source file directories, module \verb|straw.beast.main| has to be in file \verb|project/src/straw/beast/main.beast| or \verb|project/include/straw/beast/main.beast|.

\paragraph{Naming convention} Modules have to be named in lowercase (including package names), otherwise an error is shown.

\section{Project configuration}
Beast supports project configuration files in the JSON format. Items of configuration can be listed using the \inlineCode{./beast --help-config} command.

\chapter{Decorators}
%TODO noWarning, final, abstract, base, virtual, override, static, noScope, virtualBase

\begin{grammar}
	\grDef{Decoration} \kwd{@} \token{Identifier}
\end{grammar}

Generally, decorators provide syntax support for altering properties of types, declarations or even blocks of code. In the future, decorators are planned to have many practical applications. In the current Beast version, there are only two compiler-defined decorators and there is no support for user-defined decorators.

\section{Decorator application}
At module level, there are three ways of how to apply a decorator:

\begin{code}
module a;

class C {
	
// Scope decoration
@decoratorA @decoratorB:
	Int32 d;
	Int64 c;
	
	// Block decoration
	@decoratorE @decoratorF {
		Int8! b;
		Int16! c;	
	}
	
	// Statement decoration
	@decoratorC @decoratorD Int8! a;
				
}
\end{code}

\paragraph{Scope decorations} Decorators are applied to all statements following the decoration up to next scope decoration or current scope end.

\paragraph{Block decorations} Decorators are applied to all statements in the block.

\paragraph{Statement decorations} Decorators are applied to the statement that follows the decoration.

\section{Predefined decorators}

\subsection{Decorator \decoratorRef{static}} \label{decorator:static}
Decorator \decoratorRef{static} is used for declaring static variables inside functions and for declaring static nested classes (as non-static ones are not supported yet). \nopagebreak

\begin{code}
Void foo() {
	@static Int! x = 4;
	print( x );
	x = x + 1;
}

Void main() {
	foo(); //! stdout: 4
	foo(); //! stdout: 5
}
\end{code}

\subsection{Decorator \ctime} \label{decorator:ctime}
The \ctime decorator is a cornerstone of the code hatching concept (see \autoref{ctime}). It is generally associated with compile-time execution, but its exact behavior depends on the context it is used in.

\paragraph{\ctime expressions}
Decorating an expression with the \ctime decorator forces it to be evaluated at compile time. The expression can contain function calls, but it is not possible no use \nonctime variables in it. Also, some functions cannot be called during compile time, such as \inlineCode{print} (see \autoref{compilerFunctions}).

\begin{code}
Int factorial( Int x ) { /* ... */ }
	
Void main() {
	print( @ctime factorial( 12 ) ); // factorial is evaluated at compile time
}
\end{code}

\paragraph{\ctime variables}
Variables decorated with \ctime are always evaluated at compile time. They're not present in the output code at all or in a very optimized form. Local \ctime variables can be mutable (static ones not). It is not allowed to declare class members fields as \ctime variables. Some types can only be instantiated as \ctime variables, such as \inlineCode{Type} (see \autoref{typeType}).

As for now, all modifying manipulations with \ctime variables must be done in \ctime expressions. \ctime variables can be read and referenced in runtime code.

\begin{code}
@ctime Int i = 3;

print( i ); //! stdout: 3

Int? ref := i; // ref is a runtime reference
print( ref ); //! stdout: 3

@ctime i = i + 5;
print( ref ); //! stdout: 8
\end{code}

\paragraph{\decoratorRef{ctime} parameters}
A function parameter decorated with \decoratorRef{ctime} is a compile-time parameter. When calling the function, value of an argument representing a \ctime parameter must be evaluable at compile-time. A \ctime parameter is technically an alternative to generic parameters in languages like C++, D or Java. In Beast, \ctime and \nonctime parameters are inside the same parenthesis, \ctime parameters do not have to be before \nonctime and they are both manipulated with the same way. See also \autoref{function:ctimeParams}.

\begin{code}
// 'y' and 't' parameters are compile-time
Void foo( Int x, @ctime Int y, @ctime Type t ) { ... }

Void main() {
	foo( 5, 6, Int );
}
\end{code}

\paragraph{\inlineCode{@ctime if}}
When using \inlineCode{@ctime if}, the condition is evaluated at compile time, but then or else branch is not.

\begin{code}
Int x = 5;

Void foo( @ctime Type T ) {	
	@ctime if( T == Int )
		x = x + 1;
	
	print( x );
	x = x + 1;
}

Void main() {
	foo( Bool ); //! stdout: 5
	foo( Int ); //! stdout: 7
	foo( Type ); //! stdout: 8
}
\end{code}

\paragraph{\ctime code block} Contents of a code block decorated with \ctime are completely evaluated at compile time. \nopagebreak

\begin{code}
Void main() {
	@ctime Type! T := Int;
	
	T x = 5;
	print( x ); //! stdout: 5
	
	@ctime {
		Type! T2 := Int;
		
		if( T2.#instanceSize == 4 )
			T2 := Bool;
		
		T := T2;
	}
	
	T y = true;
	print( y ); //! stdout: 1
}
\end{code}

\chapter{Code hatching concept (\inlineCode{@ctime})} \label{ctime}
Code hatching concept is a new concept introduced in the Beast programming language. It unifies generic programming, compile-time function execution, reflection and generally metaprogramming. Working with these formerly separate concept is now smooth and feels like a natural part of the language with simple rules, without having to learn any special syntactic constructs.

It is based on a simple idea -- having a classifier for variables whose value is deducible during compile time. In Beast, those variables are classified using the \inlineCode{@ctime} decorator (usage \inlineCode{@ctime Int x}; see also \autoref{decorator:ctime}). Local \ctime variables can be mutable; because Beast declarations are not processed in order as they are declared in source code, order of evaluation of expressions modifying static \ctime variables cannot be decided; that means that static \ctime variables cannot be mutable. All \ctime variable manipulations are evaluated at compile time.

\ctime variables can also be included within a standard code (although their mutation can never depend on \nonctime variables or inputs).

\begin{code}
@ctime Int z = 5;

Void main() {
	@ctime Int! x = 8;
	Int! y = 16;
	y += x + z;
	x += 3;
}
\end{code}

The concept of variables completely evaluable at compile time brings a possibility of having type variables (only \ctime, runtime type variables cannot be effectively done in compiled, statically typed languages). As a consequence, class and type definitions in general can be considered \ctime constant variables (thus first-class citizens; see also \autoref{typeType}).

\begin{code}
Void main() {
	@ctime Type! T = Int;
	T x = 5;
	T = Bool;
	T b = false;
}
\end{code}

Having type variables, templates can be viewed as functions with \ctime parameters, for example class templates can be viewed functions returning a type. With \ctime variables, generics, instead of being a standalone concept, become a natural part of the language. Adding compile-time reflection is just a matter of adding compiler-defined functions returning appropriate \ctime data (not fully implemented in the current version of the language/compiler).

The \inlineCode{@ctime} decorator can also be used on more syntactical constructs than just variable definitions (see \autoref{typeType}):
\begin{compactitem}
	\item \ctime code blocks are entirely performed at compile time.
	\item \ctime branching statements (currently only \inlineCode{if}) are performed at compile time (not their bodies, just branch unwrapping).
	\item \ctime expressions are always evaluated at compile time.
\end{compactitem}

To make the code hatching concept work, it is necessary to ensure that \ctime variables are truly evaluable at compile time. That is realized by the following rules. Their deduction can be found in bachelor's thesis introducing Beast and code hatching concept (in Czech languge, downloadable from the Github repository).
\begin{compactenum}
	\item \ctime variables cannot be data-dependent on \nonctime variables. \nopagebreak
	\begin{compactenum}
		\item Data of \nonctime variables cannot be assigned into \ctime variables.
		\item It is not possible to change \ctime variables declared in a different runtime scope; for example it is not possible to change \ctime variables from a \nonctime if body if they were declared outside it.
	\end{compactenum}
	\item Static (non-local) \ctime variables must not be mutable.
	\item If a variable is \ctime, all its member variables (as class members) are also \ctime.
	\item If a reference/pointer is \ctime, the referenced data is also \ctime.
	\item \ctime variables cannot be changed from runtime (\nonctime) code.
	\item Classes cannot contain member \ctime variables.
\end{compactenum}

\chapter{Reflection} \label{reflection}
In the current version, only few reflection elements are implemented.

\section{Expressions}
Following reflection elements apply to any expression.

\begin{centeredRefTabular}{c | c | p{8cm}}
	\textbf{Data type} & \textbf{Identifier} & \textbf{Description} \\ \hline \hline
	\inlineCode{Type} & \inlineCode{#type} & Type of value the expression holds
\end{centeredRefTabular}

\begin{code}
assert( ( 5 + 3 ).#type == Int );
\end{code}

\section{Functions}
Following reflection elements apply to functions \textbf{without \ctime or \inlineCode{auto} parameters.}

\begin{centeredRefTabular}{c | c | p{8cm}}
	\textbf{Data type} & \textbf{Identifier} & \textbf{Description} \\ \hline \hline
	\inlineCode{Type} & \inlineCode{#returnType} & Return type of the function
\end{centeredRefTabular}

\section{Classes}
Following reflection elements apply to classes.

\begin{centeredRefTabular}{c | c | p{8cm}}
	\textbf{Data type} & \textbf{Identifier} & \textbf{Description} \\ \hline \hline
	\inlineCode{Size} & \inlineCode{#instanceSize} & Size of class instance in bytes
\end{centeredRefTabular}

\chapter{Beast practices \& styling guide}

\begin{itemize}
	\item Class and enum names are in \verb|UpperCamelCase|.
	\item Enum members are in \verb|lowerCamelCase|. They do not contain any enum-related prefixes.
	\item Decorator names are in \verb|lowerCamelCase|.
	\item Variable (and parameter) names are in \verb|lowerCamelCase|, type variables are in\\\verb|UpperCamelCase|.
	\item Function names are in \verb|lowerCamelCase|.
	\item The \verb|_| symbol can be used in identifiers as a separator (for example class\\\verb|PizzaIngredient_Cheese|).
\end{itemize}

\section{Further recommended code style}
\begin{itemize}
	\item Indent with tabs (so anyone can set up tab size based on his preferences)
	\item Spaces in statements like this: \inlineCode{if( expr ) \{}, opening brace on the same line
	\item Spaces around operators: \inlineCode{x + y}
	\item Decorators on the same line with decorated symbols (if the decoration list is too long).
\end{itemize}

\end{document}          
