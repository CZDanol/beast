% !TeX spellcheck = cs_CZ
% !TeX root = projekt.tex

\newcommand{\ctime}{\inlineCode{@ctime}\xspace}
\newcommand{\nonctime}{ne-\inlineCode{@ctime}\xspace}

\chapter{Úvod}
Tento dokument popisuje a zdůvodňuje část z mnoha rozhodnutí, která byla vykonána při procesu návrhu programovacího jazyka NATI a vzorového překladače pro něj. Rámcově prozkoumává syntaktické i sémantické prvky moderních programovacích jazyků a popisuje i nové koncepty a prvky.

Programovací jazyk se hodně inspiruje jazyky C++ a D\footnote{\url{http://dlang.org/}}. Tyto jazyky budou používány pro srovnávání syntaxe a efektivity psaní kódu.

\section{Motivace}
Jazyk C++ je stále jedním z nejpoužívanějších jazyků\footnote{Podle \url{http://www.tiobe.com/tiobe-index/}}. 

\begin{comment}
Mou hlavní motivací je nespokojenost se stávajícími programovacími jazyky. Programování mám jako koníčka už od nějakých dvanácti let, a tak jsem ještě před nastoupením na FIT získal nějaké zkušenosti z psaní aplikací v Object Pascalu (Delphi), C++ (Qt, SDL + OpenGL) a PHP (webové aplikace). FIT pak můj repertoár (i když jen rámcově) rozšířil na valnou většinu dnes používaných jazyků. Bohužel jsem ale nenarazil na žádný, který by splňoval mé požadavky. Rozhodl jsem se tedy využít nutnost napsání bakalářské práce k~uskutečnění mého dlouholetého snu.

\paragraph{Jazyk D}
Mému srdci nejbližší jazyk, na který jsem ve svém pátrání narazil, byl jazyk D. Jedná se o kompilovaný jazyk vycházející z C++ (binárky jsou do jisté míry kompatibilní) s~velice podobnou syntaxí. Největší rozdíly jsou modulový systém\footnote{\url{http://dlang.org/spec/module.html}} (zdrojový kód je rozdělen do modulů, které se vzájemně, i rekurzivně, importují; odpadá nutnost psát hlavičkové soubory), značně rozšířená funkčnost metaprogramování s šablonami a~rozšířená schopnost vykonávat funkce za doby kompilace.

D mi byl velikou inspirací při navrhování mého jazyka. Bohužel i v D jsem narazil na strop možnosti (ačkoli byl značně výš než třeba v C++), kdy některé věci nešly napsat tak jednoduše, jak bych chtěl. Tento jazyk však dokazuje, že tato bariéra může být mnohem dál. Já ji chci ve svém jazyku ještě více posunout. 
\end{comment}


\section{Cíle}

\chapter{Vlastnosti a syntaxe jazyka}
Nejdříve musíme určit základní rysy jazyka, které potom budeme dále rozvíjet.

\paragraph{Použití jazyka}
Naším cílem je navrhnout tzv. \textit{general purpose language}, tedy jazyk nezaměřený na konkrétní případy užití. Cílíme vytvořit "nástupce" jazyka C++, který by se dal použít ve všech případech, kde se dá využít C++ -- tedy i třeba na mikroprocesorových systémech. Složitější struktury se tím pádem budeme snažit řešit spíše vhodnou abstrakcí než zaváděním prvků, které kladou zvýšené nároky na výkon a paměť.

\paragraph{Kompilovaný vs. interpretovaný jazyk}
Ačkoli interpretované jazyky mají jisté výhody, platí se za ně pomalejším kódem a nutností zavádět interpret. V rámci této práce budeme navrhovat kompilovaný jazyk. Pro zjednodušení práce při psaní překladače nebudeme ale překládat přímo do strojového kódu, ale do jazyka C.

\paragraph{Syntaxe jazyka}
Abychom maximálně usnadnili přechod případných programátorů k našemu jazyku a zkrátili učební křivku, je vhodné se co nejvíce inspirovat již existujícími jazyky. Vzhledem k tomu, že se jedná o~kompilovaný jazyk, je nejrozumnější vycházet se syntaxe rodiny jazyků C, které jsou hojně rozšířené a zažité.

\paragraph{Programovací paradigmata}
Jelikož vycházíme z jazyků C++ a D, přejímáme i jejich paradigmata a základní koncepty. Náš jazyk bude tedy umožňovat strukturované, funkcionální i objektově orientované programování.

\section{Existující prvky programovacích jazyků}

\subsection{Systém dedičnosti tříd} Jazyky C++ a D mají různě řešené třídní systémy. Zatímco v C++ existuje jen jeden typ objektu, který pracuje s dědičností (\textit{class} a \textit{struct} jsou z pohledu dědění identické), a to s dědičností vícenásobnou a případně i~virtuální, D~má systém spíše podobný Javě -- třídy (\textit{class}) mohou mít maximálně jednoho rodiče, navíc ale existují rozhraní (\textit{interface}), které však nemohou obsahovat proměnné.

Ačkoli vícenásobné dědění není třeba často, občas potřeba je a jen těžko se nahrazuje. Rozhraní nemohou obsahovat proměnné, což omezuje jejich možnosti. D nabízí ještě jedno řešení -- tzv. \textit{template mixins}\footnote{\url{https://dlang.org/spec/template-mixin.html}} -- které funguje velice podobně jako kopírování bloků kódu přímo do těla třídy. Toto řešení rozbíjí model dědičnosti (na \textit{mixiny} se nelze odkazovat, nefungují jako rozhraní); navíc, protože jsou vložené funkce prakticky součástí třídy, nefunguje v určitých případech kontrola přepisování (\textit{overridingu}).

Ačkoli je implementace systému vícenásobné dědičnosti tak, jak je například v C++, složitější, její implementace je uskutečnitelná, kód nezpomaluje a fakticky rozšiřuje možnosti jazyka. C++ model dědičnosti umí vše, co umí Javovský model, a ještě víc.

Jazyk NATI tedy bude umožňovat třídní dědičnost, a to způsobem podobným C++. Nicméně implementace systému třídní dědičnosti není primárním cílem projektu, a tak je možné, že v rámci bakalářské práce nebude plně implementován.

Dá se přemýšlet i o zavedení různých direktiv, které umožňují dále nastavovat tento systém -- tedy například přidat možnost nastavení zamezení generování tabulky virtuálních metod, atp.

\subsection{Automatická správa paměti -- garbage collector}
Spousta moderních jazyků (mezi nimi i D) obsahuje garbage collector (dále GC) v základu. Jeho zavedení nenabízí pouze výhody -- programy mohou být pomalejší, GC zvyšuje nároky na CPU a paměť (těžko se zavádí v mikroprocesorech); navíc efektivní implementace GC je velice složitá.

Rozumným kompromisem se jeví být volitelné používání automatické správy paměti. NATI by měl umožňovat efektivní napsání GC přímo v jazyce; GC by tedy mohla být jedna ze základních knihoven jazyka. Vzhledem k už tak velkému rozsahu plánované práce je však GC jen plánem do budoucna.

\subsection{Implicitní konstantnost proměnných a propagace konstantnosti}
Koncept konstantnosti proměnných byl zaveden jednak jako prvek kontroly při psaní kódu, jednak zvětšil potenciál kompilátorů při optimalizování kódu. Označení proměnné za konstantní ale u jazyku C++ (i D, Java, ...) vyžaduje ale napsání dalšího slova (modifikátoru \textit{const} u C, C++ a D, \textit{final} u Javy), a tak tuto praktiku (označovat všechno, co se dá, jako konstantní) spousta programátorů neaplikuje, zčásti kvůli lenosti, zčásti kvůli zapomnětlivosti.

Některé jazyky (například Rust\footnote{\url{https://doc.rust-lang.org/nightly/book/mutability.html}}) přišly s opačným přístupem -- všechny proměnné jsou implicitně konstantní a programátor musí použít nějakou syntaktickou konstrukci k tomu, aby to změnil. NATI tento přístup také zavede. V rámci koherence syntaxe jazyka (která je rozvedena v dalších kapitolách tohoto textu), připadají v úvahu dvě možnosti:
\begin{enumerate}
	\item Vytvoření dekorátoru v kontextu \inlineCode{typeWrapper}\footnote{\NatiRef{Decoration contexts}}, nejlogičtěji \inlineCode{@mutable} nebo \inlineCode{@mut}
	\item Vyčlenění operátoru; nejlepším kandidátem je suffixový operátor \inlineCode{Type!}, protože nemá žádnou standardní sémantiku, je nepoužitý a znak vykřičníku je intuitivně asociován s výstrahou, což je zase asociovatelné s mutabilitou.
\end{enumerate}

Při designu NATI byla zvolena druhá možnost, především kvůli "upovídanosti" kódu a~ještě kvůli jednomu důvodu, který je popsán níže.

\paragraph{Propagace konstantnosti} Jazyk D je navržen tak, že je-li ukazatel konstantní (nelze měnit adresu, na kterou ukazuje), je přístup k paměti, na kterou ukazuje, také konstantní. Není tedy možné mít konstantní ukazatel na nekonstantní paměť. Toto je zbytečné limitování; tranzitivní konstantnost se může hodit, ale měla by být volitelná (v NATI má toto opět potenciál pro řešení v dekorátorech).

V NATI tedy nebude vynucená propagace konstantnosti; můžeme mít konstantní ukazatel na nekonstantní data. Chceme-li mít nekonstantní ukazatel na nekonstantní data, musíme tedy specifikovat mutabilitu dvakrát. Ve dříve navržených dvou případech by to tedy vypadalo takto (syntaxe pro referenci je \inlineCode{Typ?}, viz \ref{pointers}):
\begin{enumerate}
	\item \inlineCode{@mut ( @mut Typ )?}
	\item \inlineCode{Typ!?!}
\end{enumerate}

Alternativou by bylo třeba ještě zcela využít gramatiku C++, nicméně ta je všeobecně považována za velice matoucí -- dochází zde ke kombinování suffixových a prefixových modifikátorů podle neintuitivních pravidel. Čistě suffixový zápis je jasné a jednoduché pravidlo a značně snižuje potřebu využívat závorek.

\paragraph{Srovnání syntaxe C++, D a NATI}
\begin{cppcode}
	// C++
	int a, b; // Mutable integer
	const int c, d; // Const integer
	int *e, *f; // Mutable pointer to mutable integer
	const int *g, *h; // Mutable pointer to const integer
	int * const i, * const j; // Const pointer to mutable integer
	const int * const k, * const l; // Const pointer to const integer
\end{cppcode}
\begin{dcode}
	// D
	int a, b; // Mutable integer
	const int c, d; // Const integer
	int* e, f; // Mutable pointer to mutable integer
	const( int )* g, h; // Mutable pointer to const integer
	// const pointer to mutable integer not possible
	const int* k, l; // Const pointer to const integer
\end{dcode}
\begin{code}
	// NATI
	Int32! a, b; // Mutable integer
	Int32 c, d; // Const integer
	Int32!?! e, f; // Mutable reference to mutable integer
	Int32?! g, h; // Mutable reference to const integer
	Int32!? i, j; // Const reference to mutable integer
	Int32? k, l; // Const reference to const integer
\end{code}

\subsection{Typová kontrola a konverze typů}
NATI má podobný mechanismus typových kontrol jako jazyky C++ a D:
\begin{itemize}
	\item Typy mohou být implicitně konvertibilní do jiných typů. Proces konverze je definován v jednom z typů (přetížením funkcí \inlineCode{#implicitCastTo} nebo \inlineCode{#implicitCastFrom})\footnote{\NatiRef{Type casting}}. Implicitní konverze se provádí sama v případě potřeby\footnote{Implicitní konverze ovlivňuje rezoluci volání přetížených funkcí, \natiRef{Overload resolution}}.
	\item Typy mohou být explicitně konvertibilní do jiných typů (funkce \inlineCode{#explicitCastTo} a~\inlineCode{#explicitCastFrom}). K explicitnímu přetypování se používá výhradně funkce \inlineCode{a.to( Type )} (lze použít i k implicitnímu přetypování).
\end{itemize}

Důvodem k jiné syntaxi oproti C++ je opět snaha o zjednodušení pravidel a zvýšení přehlednosti kódu.

\begin{cppcode}
// C++
const int x = *( ( const int* )( voidPtr ) );
\end{cppcode}

\begin{code}
// NATI
Int32 x = voidRef.to( Int32? );
\end{code}

\subsection{Reference, ukazatelé a jejich syntaxe} \label{pointers}
Typ ukazatel umožňující ukazatelovou aritmetiku je v dnešní době považován za potenciálně nebezpečný prvek, který by se měl užívat jen v nutných případech. Toto se řeší zavedením referencí, které v různých jazycích fungují mírně rozdílně, všeobecně se ale dá říci, že se jedná o ukazatele, které nepodporují ukazatelovou aritmetiku.

V C++ reference neumožňují měnit adresu odkazované paměti. V praxi ale programátor poměrně často potřebuje měnit hodnotu odkazu a~musí se proto uchylovat k ukazatelům, které podporují ukazatelovou aritmetiku a pro přístup k odkazované hodnotě je třeba buď použít dereferenci (která je implementována prefixovým operátorem \inlineCppCode{*ptr} a má tendenci znepřehledňovat kód) nebo speciální syntaktickou konstrukci (místo \inlineCppCode{x.y} \inlineCppCode{x->y}) pro přístup k prvkům odkazované hodnoty.

D k problematice přistupuje takto:
\begin{itemize}
	\item Třídy jsou vždy předávané odkazem; adresa odkazované instance třídy se dá měnit, ukazatelová aritmetika není podporována (jako v Javě), přetěžování operátoru \inlineCode{a = b} není povoleno pro třídy jako levé operandy. Kromě tříd existují i struktury, které jsou předávané hodnotou; ty však nepodporují dědičnost.
	\item Existuje typ ukazatel, který pracuje s ukazatelovou aritmetikou. Pro přístup k odkazovanému prvku je třeba použít dereferenci (\inlineCode{*x}); k prvkům odkazované hodnoty lze použít klasické \inlineCode{x.y} (u C++ je třeba \inlineCode{x->y}). U dvojitého ukazatele je již potřeba použít dereferenci.
	\item Existuje i reference podobná té v C++, nicméně ta se dá použít pouze v několika málo případech (například v parametrech a návratových typech funkcí)
\end{itemize}

Vynucené předávání referencí má ale několik nevýhod:
\begin{itemize}
	\item Programátor musí zajišťovat konstrukci (případně i destrukci) objektů
	\item Způsobuje více alokací a dealokací
	\item Indirekce býva i tam, kde by být nemusela
\end{itemize}

\paragraph{Řešení NATI} 
NATI má umožňovat nízkoúrovňové programování, typ ukazatel s ukazatelovou aritmetikou je tedy nutné zavést. Na druhou stranu je ale vhodné nabídnout alternativu pro "běžné" případy užití, které se většinou týkají vytváření instancí tříd na haldě a manipulace s nimi. Proto náš jazyk nabízí dva ukazatelové typy, kterým říkáme ukazatel a reference.

Způsob deklarace ukazatelů je v C++ i D problematický z hlediska parsování. Výraz \inlineCode{a * b} může totiž znamenat buď výraz násobení \inlineCode{a} krát \inlineCode{b}, stejně tak ale může znamenat deklaraci proměnné \inlineCode{b} typu ukazatel na \inlineCode{a}~(obdobně i u reference). Nejjednodušším řešením je použití jiného znaku pro označování ukazatelů.

V NATI je tímto znakem otazník (\inlineCode{?}). V~C++ a~D~je používán pouze v ternárním operátoru (\inlineCode{cond ? expr1 : expr2}), kteréhož funkčnost NATI obstarává jiným způsobem\footnote{Viz \ref{ternary}}; tím pádem je znak otazníku "postradatelný".

Ukazatel funguje skoro stejně jako v C++; podporuje ukazatelovou aritmetiku. Na dereferenci se nepoužívá prefixový operátor \inlineCode{*ptr} kvůli gramatickým konfliktům a protože může způsobovat nepřehlednost kódu nejasnosti v prioritě operátorů (například u výrazu \inlineCppCode{*p++}). Místo toho se používá \inlineCode{ptr.data}\footnote{Identifikátor se ještě zvažuje}. Přístup k prvkům odkazované hodnoty je možný pouze pomocí dereference. K získání ukazatele se také, kvůli stejným důvodům, nepoužívá prefixový operátor \inlineCppCode{&variable}, nýbrž \inlineCode{variable.addr}. Typ ukazatel není deklarován pomocí zvláštní syntaktické konstrukce (suffixový operátor \inlineCode{Typ?} přenechává hojněji používaným referencím), jedná se o kompilátorem definovanou třídu \inlineCode{Pointer(Type referencedType)}.

Reference je podobná referencím v C++, navíc ale umožňuje změnu odkazované adresy (může mít i hodnotu \inlineCode{null}). Neumožňuje zanořování -- nelze definovat referenci na referenci (ukazatel na referenci ale možný je). Chová se stejně jako odkazovaná hodnota až na několik výjimek:
\begin{itemize}
	\item Je přetížen operátor \inlineCode{ref := var}, který je určen pro změnu odkazované adresy reference.
	\item Je přetížen operátor \inlineCode{ref is null}, který navrací, zda má reference hodnotu \inlineCode{null}.
	\item \inlineCode{ref.addr} vrací ukazatel na referenci objekt. \inlineCode{ref.refAddr} vrací ukazatel na odkazovaný objekt.
	\item Reference umožňují explicitní konverzi na reference předků odkazovaného typu.
\end{itemize}

Všechny typy jsou implicitně konvertibilní na referenci a reference je explicitně konvertibilní na odkazovaný typ.

Reference v NATI pokrývají naprostou většinu případů užití ukazatelů při programování na vyšších úrovních abstrakce, a to se syntaxí takovou, že programátor nemusí rozlišovat referenci od normální proměnné, když to nepotřebuje. K programování na nižší úrovni se dá použít konvenční ukazatel (typ \inlineCode{Pointer( T )}).

\subsection{Dekorátory}

\subsection{Vykonávání fukncí za doby kompilace}

\subsection{Metaprogramování}

\paragraph{Deklarace s \inlineDCode{if} v D}

\subsection{Mixiny}

\subsection{Unified function call syntax (UFCS)}

\subsection{Systém výjimek}

\subsection{Lambda výrazy}

\subsection{Traits}

\subsection{Standardní knihovna}

\section{Nové a netypické koncepty}

\subsection{Konstrukce \inlineCode{:ident}}

\subsection{Znak \inlineCode{\#} v identifikátorech}

\subsection{Ternární operátor} \label{ternary}

\subsection{Konstrukce \inlineCode{switch}}

\subsection{Vnořovatelné komentáře}

\subsection{Řetězcové literály}

\subsection{Typy IntXX, BinaryXX a Index}

\chapter{Koncept líhnutí kódu (\textit{code~hatching})}
Toto je nový koncept navržený pro jazyk NATI. Zasahuje do několika již známých konceptů -- například šablonové metaprogramování, reflexe jazyka, vykonávání funkcí za doby kompilace; všechny tyto koncepty spojuje do jednoho koherentního celku.

Koncept zavádí jednu jednoduchou myšlenku, ze které pak vyplývá celá řada důsledků. Tou myšlenkou je \textbf{zavedení klasifikátoru pro proměnné, jejichž hodnota se dá zjistit} bez nutnosti spouštět program. Tímto klasifikátorem je v~jazyce NATI dekorátor \ctime.

Vykonávání kódu tak probíhá ve dvou fázích -- hodnoty proměnných označených dekorátorem \ctime jsou odvozeny již za doby překladu, zbytek je vypočítáván za běhu samotného programu. \textbf{Toto se dá připodobnit k líhnutí vajec}, kdy se zárodek vyvíjí za skořápkou, ukryt před světem, a světlo světa spatří až jako vyvinutý jedinec.

\section{Dedukce axiomů}
Máme vyřčenou základní myšlenku -- hodnoty proměnných označených dekorátorem \ctime musíme být schopni odvodit již během kompilace; nyní tuto myšlenku budeme rozvádět. Začneme jednoduchým příkladem:
\begin{code}
@ctime Int x = 8;
\end{code}

Zde je vše jasné. Proměnná je konstantní, takže se nemůže měnit; po celou dobu její existence je její hodnota osm.

\subsection{Datové závislosti} \label{ctimeDataDependency}
Další jednoduchý příklad:
\begin{code}
@ctime Int x = console.read( Int );
\end{code}

Zde je zřejmé, že proměnná \inlineCode{x} nesplňuje naše požadavky. Příkaz \inlineCode{console.readNumber()} čte data z konzole a návratová hodnota této funkce se nedá zjistit bez spuštění programu (mohli bychom požádat o vstup již během kompilace, pro demonstraci konceptu ale toto nyní neuvažujme). Z~tohoto příkladu vyplývá, že \ctime proměnná nemůže být datově závislá na volání (alespoň některých) funkcí.

\begin{code}
Int add( Int x, Int y ) {
	return x + y;
}

Void main() {
	@ctime Int a = add( 5, 3 );
}
\end{code}
V tomto příkladě lze hodnotu proměnné \inlineCode{a} určit. \ctime tedy můžou být datově závislé na volání funkcí, ale jen některých.

\begin{code}
Int foo( Int x ) {
	if( x < 3 )
		return console.read( Int );

	return x + 1;
}

Void main() {
	@ctime Int a = foo( 5 );
	@ctime Int b = foo( 3 );
}
\end{code}

Tento příklad ukazuje, že to, zda funkce lze použít pro výpočet hodnot \ctime proměnných, může záležet na předaných parametrech.

\textbf{Funkce tedy k výpočtu hodnot \ctime proměnných všeobecně mohou být použity.} To, jestli funkce opravdu lze použít, se zjistí až během vykonávání. Nelze použít žádné funkce, u kterých kompilátor nezná chování nebo závisí na externích datech (soubory, čas, vstup uživatele, ...). Z tohoto úhlu pohledu nemá funkce smysl označovat dekorátorem \inlineCode{@ctime}; níže v této kapitole je popsáno, že se tento dekorátor na funkce používá, ale s~trochu jiným účelem.

Všeobecně se dá říci, že \ctime proměnné nemohou být závislé na \nonctime datech. Ano, hodnoty \nonctime proměnných mohou přesto být odvoditelné bez nutnosti spuštění programu, nicméně ale nemusí. Teoreticky by bylo možné klasifikátor vynechat a odvozovat to pouze z kódu, v praxi by toto však značně zpomalilo kompilaci. Předpokládejme tedy, že \textbf{hodnoty všech proměnných, které nejsou \ctime, se před spuštěním programu nedají odvodit.}

\subsection{Konstantnost}
Nyní zauvažujme nad tím, co se stane, když budeme chtít měnit hodnoty \ctime proměnných:

\begin{code}
@ctime Int! x = 8;
/* code here */
x += 2;
/* code here */
\end{code}

Zde je také všechno v pořádku. Ctime proměnné tedy nemusí být vždy konstantní.

\begin{code}
@static @ctime Int! x = 5;

Void foo() {
	@ctime Int! y = 5;
	console.write( x, y, '\n' );
	y += 3;
	x += 3;
	console.write( x, y, '\n' );
}

Void foo2() {
	x += 2;
}

Void main() {
	while( true ) {
		if( console.read( Int ) < 2 )
			foo();
		else
			foo2();
	}
}
\end{code}

Tady už narážíme na problém. Za doby kompilace nemůžeme zjistit hodnotu proměnné \inlineCode{x}, protože se přičítá na základě uživatelského vstupu. Nekonstantní statické proměnné se nedají ohlídat, \textbf{\ctime statické proměnné tedy musí být vždy konstantní}.

\subsection{Podmínky a cykly}
Větvení \textit{if-then-else} a cykly sdílejí stejný princip -- různé chování na základě nějakého výrazu. Z pohledu našeho problému se řídí stejnými pravidly.

\begin{code}
Void main() {
	@ctime Int! x = 5;
	
	while( x < 6 ) $\label{ctime:branch:1}$
		x += 3;

	Int y = console.read( Int );
	if( y < 2 ) $\label{ctime:branch:2}$
		x += 8;
}
\end{code}

Z řádku \ref{ctime:branch:1} je patrné, že větvení v rámci \ctime proměnných je možné. Řádek \ref{ctime:branch:2} zase ukazuje, že to není možné vždy. Pokud je větvení datově závislé na výrazu, jehož hodnota se dá odvodit za doby kompilace (dále jen \ctime výrazu), mohou být v jeho těle přítomny \ctime proměnné. Pro usnadnění práce kompilátoru a zpřehlednění kódu NATI vyžaduje, aby \ctime větvení byly označeny dekorátorem (jinak se k nim přistupuje jako k \nonctime, viz dále).

Problematika je ale trochu složitější:

\begin{code}
Void main() {
	@ctime Int! y = 6;

	while( console.read( Int ) < 5 ) {
		@ctime Int! z = 3;
				
		console.write( y );	$\label{ctime:branch:3}$
		console.write( z );
		
		z += 4;
		console.write( z + y );
		
		y += 2;
	}
}
\end{code}

Zde máme proměnnou \inlineCode{z}, která je definovaná v těle \nonctime cyklu. Nicméně takovéto použití proměnné jako v příkladu naše požadavky nenarušuje, stejně tak čtení z proměnné \inlineCode{y} na řádku \ref{ctime:branch:3}. V \nonctime větveních tedy mohou být použity \ctime proměnné a dokonce i definovány nekonstantní \ctime proměnné. Pravidlo, které se z tohoto příkladu dá vyvodit, je že \textbf{v tělech \nonctime větvení nelze měnit hodnoty \ctime proměnných deklarovaných mimo tělo.}

\subsection{Reference}

\subsection{Přetypování na \nonctime}

\section{Konečný přehled pravidel}
\begin{enumerate}
	\item \ctime proměnné nemohou být jakkoli (datově) závislé na proměnných, které nejsou \ctime. 
	\item Statické \ctime proměnné musí být konstantní
	\item Větvení může být \ctime, pokud je výraz v nich datově závislý pouze na \ctime proměnných
	\begin{enumerate}
		\item Těla \ctime větvení nejsou nijak omezena
		\item V tělech \nonctime větvení se nemůže měnit data \ctime proměnných, které byly deklarovány mimo tělo (lze je číst)
	\end{enumerate}
\end{enumerate}

\section{Potenciály konceptu}

\subsection{Vykonávání funkcí za doby kompilace}

\subsection{Šablonování a unifikace šablonových a klasických parametrů}

\subsection{Typové proměnné}

\subsection{\ctime třídy}

\subsection{Reflexe kódu}